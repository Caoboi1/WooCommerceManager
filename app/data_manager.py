"""
Data Manager Tab - Qu·∫£n l√Ω v√† t·ªëi ∆∞u d·ªØ li·ªáu folder scans
"""

import os
import logging
import json
from typing import List, Dict, Any, Optional
from datetime import datetime
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem,
    QPushButton, QLabel, QComboBox, QTextEdit, QDialog, QProgressDialog,
    QGroupBox, QSplitter, QMessageBox, QFileDialog, QInputDialog,
    QTabWidget, QFormLayout, QSpinBox, QCheckBox, QHeaderView, QLineEdit,
    QProgressBar, QAbstractItemView
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QTimer
from PyQt6.QtGui import QFont, QColor

from app.database import DatabaseManager


class DataCleanupWorker(QThread):
    """Worker thread cho cleanup data"""

    progress_update = pyqtSignal(int, str)
    finished = pyqtSignal(bool, str, dict)

    def __init__(self, db_manager: DatabaseManager, cleanup_options: Dict[str, bool]):
        super().__init__()
        self.db_manager = db_manager
        self.cleanup_options = cleanup_options
        self.results = {}

    def run(self):
        """Ch·∫°y cleanup"""
        try:
            total_steps = sum(1 for option in self.cleanup_options.values() if option)
            current_step = 0

            # Cleanup orphaned folders
            if self.cleanup_options.get('orphaned_folders', False):
                current_step += 1
                self.progress_update.emit(
                    int((current_step / total_steps) * 100),
                    "ƒêang d·ªçn d·∫πp folder scans kh√¥ng c√≤n t·ªìn t·∫°i..."
                )
                deleted_count = self.db_manager.cleanup_orphaned_folder_scans()
                self.results['orphaned_deleted'] = deleted_count

            # Find and optionally merge duplicates
            if self.cleanup_options.get('duplicate_folders', False):
                current_step += 1
                self.progress_update.emit(
                    int((current_step / total_steps) * 100),
                    "ƒêang t√¨m v√† x·ª≠ l√Ω folder scans tr√πng l·∫∑p..."
                )
                duplicates = self.db_manager.get_duplicate_folder_scans()
                self.results['duplicates_found'] = len(duplicates)

                # Auto-merge duplicates
                merged_count = 0
                for dup in duplicates:
                    if len(dup['ids']) > 1:
                        keep_id = min(dup['ids'])  # Gi·ªØ l·∫°i ID nh·ªè nh·∫•t
                        merge_ids = [id for id in dup['ids'] if id != keep_id]
                        if self.db_manager.merge_duplicate_folder_scans(keep_id, merge_ids):
                            merged_count += 1

                self.results['duplicates_merged'] = merged_count

            # Fix missing data_names
            if self.cleanup_options.get('missing_data_names', False):
                current_step += 1
                self.progress_update.emit(
                    int((current_step / total_steps) * 100),
                    "ƒêang s·ª≠a data_name tr·ªëng..."
                )
                folders = self.db_manager.get_all_folder_scans()
                fixed_count = 0

                for folder in folders:
                    if not folder.get('data_name') or folder.get('data_name', '').strip() == '':
                        original_title = folder.get('original_title', '')
                        if original_title and folder.get('id'):
                            success = self.db_manager.update_folder_scan(
                                folder.get('id'), 
                                {'data_name': original_title}
                            )
                            if success:
                                fixed_count += 1

                self.results['data_names_fixed'] = fixed_count

            # Optimize database
            if self.cleanup_options.get('optimize_db', False):
                current_step += 1
                self.progress_update.emit(
                    int((current_step / total_steps) * 100),
                    "ƒêang t·ªëi ∆∞u database..."
                )
                self.db_manager.optimize_folder_scans_table()
                self.results['db_optimized'] = True

            self.progress_update.emit(100, "Ho√†n th√†nh cleanup!")
            self.finished.emit(True, "Cleanup ho√†n th√†nh th√†nh c√¥ng!", self.results)

        except Exception as e:
            self.finished.emit(False, f"L·ªói cleanup: {str(e)}", {})


class DataManagerTab(QWidget):
    """Tab qu·∫£n l√Ω data"""

    def __init__(self):
        super().__init__()
        self.logger = logging.getLogger(__name__)

        try:
            from app.database import DatabaseManager
            self.db_manager = DatabaseManager()
            self.cleanup_worker = None

            self.init_ui()
            self.load_summary()

        except Exception as e:
            self.logger.error(f"Error initializing DataManagerTab: {str(e)}")
            layout = QVBoxLayout(self)
            error_label = QLabel(f"L·ªói kh·ªüi t·∫°o: {str(e)}")
            layout.addWidget(error_label)

    def init_ui(self):
        """Kh·ªüi t·∫°o giao di·ªán"""
        # X√≥a layout c≈© n·∫øu c√≥
        if self.layout():
            old_layout = self.layout()
            # X√≥a t·∫•t c·∫£ widgets t·ª´ layout c≈©
            while old_layout.count():
                item = old_layout.takeAt(0)
                if item.widget():
                    item.widget().deleteLater()
            # X√≥a layout c≈©
            old_layout.deleteLater()

        # T·∫°o layout m·ªõi
        layout = QVBoxLayout()
        self.setLayout(layout)

        # Th√™m c√°c widgets v√†o layout m·ªõi
        # Header
        header_layout = QHBoxLayout()

        title_label = QLabel("üìä Qu·∫£n l√Ω Data Folder Scans")
        title_label.setFont(QFont("Arial", 14, QFont.Weight.Bold))
        header_layout.addWidget(title_label)

        layout.addLayout(header_layout)

        # Tab widget
        self.tab_widget = QTabWidget()

        # Overview tab
        self.overview_tab = self.create_overview_tab()
        self.tab_widget.addTab(self.overview_tab, "üìä T·ªïng quan")

        # Cleanup tab
        self.cleanup_tab = self.create_cleanup_tab()
        self.tab_widget.addTab(self.cleanup_tab, "üßπ D·ªçn d·∫πp")

        # Export/Import tab
        self.export_tab = self.create_export_tab()
        self.tab_widget.addTab(self.export_tab, "üì§ Xu·∫•t/Nh·∫≠p")

        # Upload tab
        self.upload_tab = self.create_upload_tab()
        self.tab_widget.addTab(self.upload_tab, "‚¨ÜÔ∏è D·ªØ li·ªáu ƒëƒÉng")

        layout.addWidget(self.tab_widget)

    def create_overview_tab(self) -> QWidget:
        """T·∫°o tab t·ªïng quan"""
        widget = QWidget()
        layout = QVBoxLayout(widget)

        # Summary stats
        stats_group = QGroupBox("üìà Th·ªëng k√™ t·ªïng quan")
        stats_layout = QFormLayout(stats_group)

        self.total_folders_label = QLabel("0")
        stats_layout.addRow("T·ªïng s·ªë folder:", self.total_folders_label)

        self.total_images_label = QLabel("0")
        stats_layout.addRow("T·ªïng s·ªë ·∫£nh:", self.total_images_label)

        self.pending_folders_label = QLabel("0")
        stats_layout.addRow("Folder ch·ªù x·ª≠ l√Ω:", self.pending_folders_label)

        self.completed_folders_label = QLabel("0")
        stats_layout.addRow("Folder ho√†n th√†nh:", self.completed_folders_label)

        layout.addWidget(stats_group)

        # Detailed data table
        data_group = QGroupBox("üìã Chi ti·∫øt d·ªØ li·ªáu qu√©t th∆∞ m·ª•c")
        data_layout = QVBoxLayout(data_group)

        # Filter controls
        filter_layout = QHBoxLayout()

        # Batch filter
        filter_layout.addWidget(QLabel("Ch·ªçn batch:"))
        self.filter_batch_combo = QComboBox()
        self.filter_batch_combo.addItem("T·∫•t c·∫£ d·ªØ li·ªáu", None)
        # Disconnect any existing connections to prevent duplicates
        try:
            self.filter_batch_combo.currentTextChanged.disconnect()
        except:
            pass
        self.filter_batch_combo.currentTextChanged.connect(self.load_detailed_data)
        filter_layout.addWidget(self.filter_batch_combo)

        filter_layout.addWidget(QLabel("L·ªçc theo site:"))
        self.filter_site_combo = QComboBox()
        try:
            self.filter_site_combo.currentTextChanged.disconnect()
        except:
            pass
        self.filter_site_combo.currentTextChanged.connect(self.load_detailed_data)
        filter_layout.addWidget(self.filter_site_combo)

        filter_layout.addWidget(QLabel("Tr·∫°ng th√°i:"))
        self.filter_status_combo = QComboBox()
        self.filter_status_combo.addItems(["T·∫•t c·∫£", "pending", "completed", "uploaded"])
        try:
            self.filter_status_combo.currentTextChanged.disconnect()
        except:
            pass
        self.filter_status_combo.currentTextChanged.connect(self.load_detailed_data)
        filter_layout.addWidget(self.filter_status_combo)

        filter_layout.addStretch()

        # Refresh button kept in filter_layout
        refresh_btn = QPushButton("üîÑ L√†m m·ªõi")
        refresh_btn.clicked.connect(self.load_detailed_data)
        filter_layout.addWidget(refresh_btn)

        data_layout.addLayout(filter_layout)

        # Data table v·ªõi c·∫•u tr√∫c c·ªôt t·ªëi ∆∞u
        self.data_table = QTableWidget()
        self.data_table.setColumnCount(7)
        self.data_table.setHorizontalHeaderLabels([
            "T√™n s·∫£n ph·∫©m", "S·ªë ·∫£nh", "Site", "Danh m·ª•c", "Tr·∫°ng th√°i", "Ng√†y t·∫°o", "Thao t√°c"
        ])

        # Thi·∫øt l·∫≠p responsive grid layout cho b·∫£ng
        header = self.data_table.horizontalHeader()

        # Thay th·∫ø ƒëo·∫°n code c≈© v·ªõi resize modes m·ªõi
        resize_modes = [
            QHeaderView.ResizeMode.Interactive,     # T√™n s·∫£n ph·∫©m - co d√£n 
            QHeaderView.ResizeMode.Fixed,           # S·ªë ·∫£nh - c·ªë ƒë·ªãnh
            QHeaderView.ResizeMode.ResizeToContents,# Site - theo n·ªôi dung  
            QHeaderView.ResizeMode.ResizeToContents,# Danh m·ª•c - theo n·ªôi dung
            QHeaderView.ResizeMode.Fixed,           # Tr·∫°ng th√°i - c·ªë ƒë·ªãnh 
            QHeaderView.ResizeMode.Fixed,           # Ng√†y t·∫°o - c·ªë ƒë·ªãnh
            QHeaderView.ResizeMode.Fixed            # Thao t√°c - c·ªë ƒë·ªãnh
        ]

        # √Åp d·ª•ng resize mode cho t·ª´ng c·ªôt
        for col, mode in enumerate(resize_modes):
            header.setSectionResizeMode(col, mode)

        # Thi·∫øt l·∫≠p width c·ªë ƒë·ªãnh cho c√°c c·ªôt Fixed
        self.data_table.setColumnWidth(1, 80)    # S·ªë ·∫£nh
        self.data_table.setColumnWidth(4, 100)   # Tr·∫°ng th√°i
        self.data_table.setColumnWidth(5, 130)   # Ng√†y t·∫°o
        self.data_table.setColumnWidth(6, 120)   # Thao t√°c

        # C·∫•u h√¨nh responsive header v·ªõi kh·∫£ nƒÉng k√©o th·∫£
        header.setStretchLastSection(False)
        header.setSectionsMovable(True)           # Cho ph√©p k√©o th·∫£ di chuy·ªÉn c·ªôt
        header.setSectionsClickable(True)         # Cho ph√©p click ƒë·ªÉ sort
        header.setMinimumSectionSize(40)
        header.setDefaultSectionSize(120)

        # Context menu cho header ƒë·ªÉ reset column sizes
        header.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        header.customContextMenuRequested.connect(self.show_header_context_menu)

        self.data_table.setAlternatingRowColors(True)
        self.data_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.data_table.setSortingEnabled(True)
        self.data_table.itemSelectionChanged.connect(self.on_data_selection_changed)

        data_layout.addWidget(self.data_table)

        # Data action buttons v·ªõi nhi·ªÅu t√≠nh nƒÉng h∆°n
        data_buttons_layout = QHBoxLayout()

        # Nh√≥m buttons ch√≠nh
        main_buttons_group = QHBoxLayout()

        # T√¨m ki·∫øm nhanh
        search_layout = QHBoxLayout()
        search_label = QLabel("üîç T√¨m ki·∫øm:")
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Nh·∫≠p t√™n s·∫£n ph·∫©m, site, ho·∫∑c danh m·ª•c...")
        try:
            self.search_input.textChanged.disconnect()
        except:
            pass
        self.search_input.textChanged.connect(self.on_search_changed)
        search_layout.addWidget(search_label)
        search_layout.addWidget(self.search_input)
        main_buttons_group.addLayout(search_layout)

        main_buttons_group.addStretch()

        # Buttons h√†nh ƒë·ªông
        action_buttons_layout = QHBoxLayout()

        self.edit_data_btn = QPushButton("‚úèÔ∏è Ch·ªânh s·ª≠a")
        self.edit_data_btn.setStyleSheet("QPushButton { background-color: #4CAF50; color: white; font-weight: bold; padding: 8px 16px; border-radius: 4px; }")

        self.view_details_btn = QPushButton("üëÅÔ∏è Xem chi ti·∫øt")
        self.view_details_btn.setStyleSheet("QPushButton { background-color: #2196F3; color: white; font-weight: bold; padding: 8px 16px; border-radius: 4px; }")

        self.bulk_edit_btn = QPushButton("üìù S·ª≠a h√†ng lo·∫°t")
        self.bulk_edit_btn.setStyleSheet("QPushButton { background-color: #FF9800; color: white; font-weight: bold; padding: 8px 16px; border-radius: 4px; }")

        self.delete_data_btn = QPushButton("üóëÔ∏è X√≥a")
        self.delete_data_btn.setStyleSheet("QPushButton { background-color: #f44336; color: white; font-weight: bold; padding: 8px 16px; border-radius: 4px; }")

        self.export_selected_btn = QPushButton("üì§ Xu·∫•t d·ªØ li·ªáu")
        self.export_selected_btn.setStyleSheet("QPushButton { background-color: #9C27B0; color: white; font-weight: bold; padding: 8px 16px; border-radius: 4px; }")

        action_buttons_layout.addWidget(self.edit_data_btn)
        action_buttons_layout.addWidget(self.view_details_btn)
        action_buttons_layout.addWidget(self.bulk_edit_btn)
        action_buttons_layout.addWidget(self.delete_data_btn)
        action_buttons_layout.addWidget(self.export_selected_btn)

        data_buttons_layout.addLayout(main_buttons_group)
        data_buttons_layout.addLayout(action_buttons_layout)

        # Connect button signals
        self.edit_data_btn.clicked.connect(self.edit_selected_data)
        self.view_details_btn.clicked.connect(self.view_data_details)
        self.bulk_edit_btn.clicked.connect(self.on_bulk_edit_selected)
        self.delete_data_btn.clicked.connect(self.delete_selected_data_batch)
        self.export_selected_btn.clicked.connect(self.on_export_selected_data)

        # Disable buttons initially
        self.edit_data_btn.setEnabled(False)
        self.view_details_btn.setEnabled(False)
        self.bulk_edit_btn.setEnabled(False)
        self.delete_data_btn.setEnabled(False)
        self.export_selected_btn.setEnabled(False)
        self.view_details_btn.setEnabled(False)
        data_buttons_layout.addWidget(self.view_details_btn)

        data_buttons_layout.addSpacing(20)

        self.load_saved_scans_btn = QPushButton("üì¶ Load t·ª´ Saved Scans")
        self.load_saved_scans_btn.clicked.connect(self.show_saved_scans_dialog)
        self.load_saved_scans_btn.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                color: white;
                font-weight: bold;
                padding: 8px 16px;
                border: none;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #218838;
            }
        """)
        data_buttons_layout.addWidget(self.load_saved_scans_btn)

        data_buttons_layout.addStretch()

        data_layout.addLayout(data_buttons_layout)

        layout.addWidget(data_group)

        return widget

    def create_cleanup_tab(self) -> QWidget:
        """T·∫°o tab d·ªçn d·∫πp"""
        widget = QWidget()
        layout = QVBoxLayout(widget)

        # Cleanup options
        options_group = QGroupBox("üßπ T√πy ch·ªçn d·ªçn d·∫πp")
        options_layout = QVBoxLayout(options_group)

        self.orphaned_check = QCheckBox("X√≥a folder scans kh√¥ng c√≤n t·ªìn t·∫°i tr√™n disk")
        self.orphaned_check.setChecked(True)
        options_layout.addWidget(self.orphaned_check)

        self.duplicate_check = QCheckBox("G·ªôp folder scans tr√πng l·∫∑p")
        self.duplicate_check.setChecked(True)
        options_layout.addWidget(self.duplicate_check)

        self.missing_names_check = QCheckBox("S·ª≠a data_name tr·ªëng")
        self.missing_names_check.setChecked(True)
        options_layout.addWidget(self.missing_names_check)

        self.optimize_check = QCheckBox("T·ªëi ∆∞u database")
        self.optimize_check.setChecked(False)
        options_layout.addWidget(self.optimize_check)

        layout.addWidget(options_group)

        # Cleanup actions
        actions_group = QGroupBox("‚ö° Thao t√°c")
        actions_layout = QHBoxLayout(actions_group)

        self.cleanup_btn = QPushButton("üßπ B·∫Øt ƒë·∫ßu d·ªçn d·∫πp")
        self.cleanup_btn.clicked.connect(self.start_cleanup)
        actions_layout.addWidget(self.cleanup_btn)

        self.preview_btn = QPushButton("üëÄ Xem tr∆∞·ªõc")
        self.preview_btn.clicked.connect(self.preview_cleanup)
        actions_layout.addWidget(self.preview_btn)

        actions_layout.addStretch()

        layout.addWidget(actions_group)

        # Results
        self.cleanup_results = QTextEdit()
        self.cleanup_results.setMaximumHeight(200)
        self.cleanup_results.setPlainText("Ch∆∞a th·ª±c hi·ªán cleanup n√†o...")
        layout.addWidget(self.cleanup_results)

        layout.addStretch()
        return widget

    def create_export_tab(self) -> QWidget:
        """T·∫°o tab xu·∫•t/nh·∫≠p"""
        widget = QWidget()
        layout = QVBoxLayout(widget)

        # Export section
        export_group = QGroupBox("üì§ Xu·∫•t d·ªØ li·ªáu")
        export_layout = QVBoxLayout(export_group)

        export_buttons = QHBoxLayout()

        self.export_json_btn = QPushButton("üìÑ Xu·∫•t JSON")
        self.export_json_btn.clicked.connect(self.export_to_json)
        export_buttons.addWidget(self.export_json_btn)

        self.export_csv_btn = QPushButton("üìä Xu·∫•t CSV")
        self.export_csv_btn.clicked.connect(self.export_to_csv)
        export_buttons.addWidget(self.export_csv_btn)

        export_buttons.addStretch()

        export_layout.addLayout(export_buttons)
        layout.addWidget(export_group)

        # Backup section
        backup_group = QGroupBox("üíæ Sao l∆∞u")
        backup_layout = QVBoxLayout(backup_group)

        backup_buttons = QHBoxLayout()

        self.backup_db_btn = QPushButton("üíæ Sao l∆∞u Database")
        self.backup_db_btn.clicked.connect(self.backup_database)
        backup_buttons.addWidget(self.backup_db_btn)

        self.restore_db_btn = QPushButton("üì• Kh√¥i ph·ª•c Database")
        self.restore_db_btn.clicked.connect(self.restore_database)
        backup_buttons.addWidget(self.restore_db_btn)

        backup_buttons.addStretch()

        backup_layout.addLayout(backup_buttons)
        layout.addWidget(backup_group)

        layout.addStretch()
        return widget

    def create_upload_tab(self) -> QWidget:
        """T·∫°o tab upload scheduler"""
        widget = QWidget()
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(12, 12, 12, 12)
        layout.setSpacing(12)

        # Control panel
        control_group = QGroupBox("üéõÔ∏è ƒêi·ªÅu khi·ªÉn upload")
        control_group.setStyleSheet("QGroupBox { font-weight: bold; padding-top: 15px; }")
        control_layout = QHBoxLayout(control_group)

        # Batch selector
        control_layout.addWidget(QLabel("Ch·ªçn batch:"))
        self.upload_batch_combo = QComboBox()
        self.upload_batch_combo.setMinimumWidth(200)
        self.upload_batch_combo.addItem("Ch·ªçn t·ª´ b·∫£ng chi ti·∫øt", None)
        control_layout.addWidget(self.upload_batch_combo)

        # Load batch button
        self.load_batch_btn = QPushButton("üì¶ Load batch")
        self.load_batch_btn.clicked.connect(self.load_batch_upload_data)
        self.load_batch_btn.setEnabled(False)
        control_layout.addWidget(self.load_batch_btn)

        # Refresh upload data button
        self.refresh_upload_btn = QPushButton("üîÑ L√†m m·ªõi")
        self.refresh_upload_btn.clicked.connect(self.refresh_upload_data)
        self.refresh_upload_btn.setStyleSheet("""
            QPushButton {
                background-color: #17a2b8;
                color: white;
                font-weight: bold;
                padding: 8px 16px;
                border: none;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #138496;
            }
        """)
        control_layout.addWidget(self.refresh_upload_btn)



        # Config button
        self.config_upload_btn = QPushButton("‚öôÔ∏è Thi·∫øt l·∫≠p c·∫•u h√¨nh ƒëƒÉng")
        self.config_upload_btn.clicked.connect(self.show_upload_config)
        self.config_upload_btn.setEnabled(False)
        self.config_upload_btn.setToolTip("M·ªü dialog c·∫•u h√¨nh chi ti·∫øt cho vi·ªác ƒëƒÉng s·∫£n ph·∫©m")
        control_layout.addWidget(self.config_upload_btn)

        # Di chuy·ªÉn c√°c n√∫t ƒëi·ªÅu khi·ªÉn upload v√†o ƒë√¢y
        self.pause_upload_btn = QPushButton("‚è∏Ô∏è T·∫°m d·ª´ng")
        self.pause_upload_btn.clicked.connect(self.pause_upload)
        self.pause_upload_btn.setEnabled(False)
        self.pause_upload_btn.setStyleSheet("""
            QPushButton {
                background-color: #ffc107;
                color: black;
                font-weight: bold;
                padding: 8px 16px;
                border: none;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #e0a800;
            }
            QPushButton:disabled {
                background-color: #6c757d;
                color: #ffffff;
            }
        """)
        control_layout.addWidget(self.pause_upload_btn)

        self.resume_upload_btn = QPushButton("‚ñ∂Ô∏è Ti·∫øp t·ª•c")
        self.resume_upload_btn.clicked.connect(self.resume_upload)
        self.resume_upload_btn.setEnabled(False)
        self.resume_upload_btn.setVisible(False)
        self.resume_upload_btn.setStyleSheet("""
            QPushButton {
                background-color: #17a2b8;
                color: white;
                font-weight: bold;
                padding: 8px 16px;
                border: none;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #138496;
            }
            QPushButton:disabled {
                background-color: #6c757d;
                color: #ffffff;
            }
        """)
        control_layout.addWidget(self.resume_upload_btn)

        self.stop_upload_btn = QPushButton("‚èπÔ∏è D·ª´ng")
        self.stop_upload_btn.clicked.connect(self.stop_upload)
        self.stop_upload_btn.setEnabled(False)
        self.stop_upload_btn.setStyleSheet("""
            QPushButton {
                background-color: #dc3545;
                color: white;
                font-weight: bold;
                padding: 8px 16px;
                border: none;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #c82333;
            }
            QPushButton:disabled {
                background-color: #6c757d;
                color: #ffffff;
            }
        """)
        control_layout.addWidget(self.stop_upload_btn)

        control_layout.addStretch()

        # Delay setting
        control_layout.addWidget(QLabel("Th·ªùi gian ch·ªù:"))
        self.upload_delay_spin = QSpinBox()
        self.upload_delay_spin.setRange(1, 60)
        self.upload_delay_spin.setValue(3)
        self.upload_delay_spin.setSuffix(" gi√¢y")
        control_layout.addWidget(self.upload_delay_spin)

        layout.addWidget(control_group)

        # Status and controls
        status_group = QGroupBox("üìä Tr·∫°ng th√°i upload")
        status_group.setStyleSheet("QGroupBox { font-weight: bold; padding-top: 15px; }")
        status_layout = QVBoxLayout(status_group)

        # Progress info
        progress_info_layout = QHBoxLayout()

        self.upload_status_label = QLabel("S·∫µn s√†ng upload")
        self.upload_status_label.setFont(QFont("Arial", 11, QFont.Weight.Bold))
        progress_info_layout.addWidget(self.upload_status_label)

        progress_info_layout.addStretch()

        self.upload_progress_label = QLabel("0/0")
        self.upload_progress_label.setFont(QFont("Arial", 11, QFont.Weight.Bold))
        progress_info_layout.addWidget(self.upload_progress_label)

        status_layout.addLayout(progress_info_layout)

        # Th√™m label hi·ªÉn th·ªã th·ªëng k√™ chi ti·∫øt
        self.upload_stats_label = QLabel("Ch·ªçn batch ƒë·ªÉ xem th·ªëng k√™")
        self.upload_stats_label.setFont(QFont("Arial", 9))
        self.upload_stats_label.setStyleSheet("color: #666; padding: 5px;")
        self.upload_stats_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        status_layout.addWidget(self.upload_stats_label)

        # Progress bar
        self.upload_progress_bar = QProgressBar()
        self.upload_progress_bar.setVisible(False)
        status_layout.addWidget(self.upload_progress_bar)

        # Control buttons
        control_buttons_layout = QHBoxLayout()

        self.start_upload_btn = QPushButton("üöÄ B·∫Øt ƒë·∫ßu ƒëƒÉng h√†ng lo·∫°t")
        self.start_upload_btn.clicked.connect(self.start_upload_scheduler)
        self.start_upload_btn.setEnabled(False)
        self.start_upload_btn.setToolTip("B·∫Øt ƒë·∫ßu upload v·ªõi c·∫•u h√¨nh ƒë√£ thi·∫øt l·∫≠p")
        self.start_upload_btn.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                color: white;
                font-weight: bold;
                padding: 8px 16px;
                border: none;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #218838;
            }
            QPushButton:disabled {
                background-color: #6c757d;
                color: #ffffff;
            }
        """)
        control_buttons_layout.addWidget(self.start_upload_btn)  # Th√™m d·∫•u ƒë√≥ng ngo·∫∑c

        self.clear_queue_btn = QPushButton("üóëÔ∏è X√≥a h√†ng ƒë·ª£i")
        self.clear_queue_btn.clicked.connect(self.clear_upload_queue)
        self.clear_queue_btn.setEnabled(False)
        control_buttons_layout.addWidget(self.clear_queue_btn)

        self.remove_selected_btn = QPushButton("‚ûñ X√≥a ƒë√£ ch·ªçn")
        self.remove_selected_btn.clicked.connect(self.remove_selected_from_queue)
        self.remove_selected_btn.setEnabled(False)
        control_buttons_layout.addWidget(self.remove_selected_btn)

        # Refresh queue button
        self.refresh_queue_btn = QPushButton("üîÑ L√†m m·ªõi h√†ng ƒë·ª£i")
        self.refresh_queue_btn.clicked.connect(self.refresh_upload_queue)
        self.refresh_queue_btn.setStyleSheet("""
            QPushButton {
                background-color: #6c757d;
                color: white;
                font-weight: bold;
                padding: 8px 16px;
                border: none;
                border-radius: 4px;
            }
            QPushButton:hover {
                background-color: #5a6268;
            }
        """)
        control_buttons_layout.addWidget(self.refresh_queue_btn)

        control_buttons_layout.addStretch()

        status_layout.addLayout(control_buttons_layout)

        layout.addWidget(status_group)

        # Upload queue table
        queue_group = QGroupBox("üìã H√†ng ƒë·ª£i upload")
        queue_group.setStyleSheet("QGroupBox { font-weight: bold; padding-top: 15px; }")
        queue_layout = QVBoxLayout(queue_group)

        # Table
        self.upload_queue_table = QTableWidget()
        self.upload_queue_table.setColumnCount(9)
        self.upload_queue_table.setHorizontalHeaderLabels([
            "T√™n s·∫£n ph·∫©m", "ƒê∆∞·ªùng d·∫´n", "S·ªë ·∫£nh", "Danh m·ª•c", "M√¥ t·∫£", "Site ƒëƒÉng", "Tr·∫°ng th√°i", "Log", "Th·ªùi gian"
        ])

        # Table properties
        self.upload_queue_table.setAlternatingRowColors(True)
        self.upload_queue_table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)

        # Header settings
        header = self.upload_queue_table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)  # T√™n s·∫£n ph·∫©m
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)  # ƒê∆∞·ªùng d·∫´n
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.Fixed)  # S·ªë ·∫£nh
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)  # Danh m·ª•c
        header.setSectionResizeMode(4, QHeaderView.ResizeMode.Stretch)  # M√¥ t·∫£
        header.setSectionResizeMode(5, QHeaderView.ResizeMode.ResizeToContents)  # Site ƒëƒÉng
        header.setSectionResizeMode(6, QHeaderView.ResizeMode.ResizeToContents)  # Tr·∫°ng th√°i
        header.setSectionResizeMode(7, QHeaderView.ResizeMode.Stretch)  # Log
        header.setSectionResizeMode(8, QHeaderView.ResizeMode.ResizeToContents)  # Th·ªùi gian

        self.upload_queue_table.setColumnWidth(2, 80)  # S·ªë ·∫£nh

        # Connect selection changed signal
        self.upload_queue_table.itemSelectionChanged.connect(self.on_queue_selection_changed)

        queue_layout.addWidget(self.upload_queue_table)

        layout.addWidget(queue_group)

        # Initialize upload data
        self.upload_folders = []
        self.upload_config = {
            'configured': False,
            'default_site_id': None,
            'default_category_id': None,
            'default_status': 'draft',
            'image_gallery': True,
            'auto_description': True
        }

        return widget

    def load_summary(self):
        """Load th·ªëng k√™ t·ªïng quan v·ªõi sync database"""
        try:
            summary = self.db_manager.get_folder_scans_summary()

            # Update summary labels
            self.total_folders_label.setText(str(summary.get('total_folders', 0)))
            self.total_images_label.setText(str(summary.get('total_images', 0)))

            status_stats = summary.get('by_status', {})
            pending_count = status_stats.get('pending', 0)
            completed_count = status_stats.get('completed', 0)
            uploaded_count = status_stats.get('uploaded', 0)  # Th√™m uploaded count
            
            # Hi·ªÉn th·ªã th·ªëng k√™ chi ti·∫øt h∆°n
            self.pending_folders_label.setText(f"{pending_count} (ch·ªù x·ª≠ l√Ω)")
            
            # T·ªïng h·ª£p completed + uploaded
            total_processed = completed_count + uploaded_count
            self.completed_folders_label.setText(f"{total_processed} (ƒë√£ x·ª≠ l√Ω)")
            
            self.logger.info(f"üìä Summary refreshed - Pending: {pending_count}, Completed: {completed_count}, Uploaded: {uploaded_count}")

            # Load batch filter
            self.load_batch_filter()

            # Load upload batch selector
            self.load_upload_batch_selector()

            # Load sites for filter
            self.load_sites_filter()

            # Load detailed data v·ªõi force refresh
            self.load_detailed_data()
            
            # Log ƒë·ªÉ debug data consistency
            self.log_data_consistency_check()

        except Exception as e:
            self.logger.error(f"Error loading summary: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ load th·ªëng k√™: {str(e)}")

    def log_data_consistency_check(self):
        """Log ƒë·ªÉ ki·ªÉm tra t√≠nh nh·∫•t qu√°n c·ªßa d·ªØ li·ªáu"""
        try:
            # Ki·ªÉm tra consistency gi·ªØa folder_scans v√† saved_scans
            folder_scans = self.db_manager.get_all_folder_scans()
            saved_scans = self.db_manager.get_all_saved_scans()
            
            # ƒê·∫øm status t·ª´ folder_scans table
            folder_status_count = {}
            for folder in folder_scans:
                status = folder.get('status', 'pending')
                folder_status_count[status] = folder_status_count.get(status, 0) + 1
            
            # ƒê·∫øm status t·ª´ saved_scans data
            saved_status_count = {}
            for saved_scan in saved_scans:
                try:
                    import json
                    data_json = saved_scan.get('data', '[]')
                    if isinstance(data_json, str):
                        folders_data = json.loads(data_json)
                    else:
                        folders_data = data_json
                    
                    for folder in folders_data:
                        status = folder.get('status', 'pending')
                        saved_status_count[status] = saved_status_count.get(status, 0) + 1
                except:
                    continue
            
            self.logger.info(f"üîç Consistency Check - Folder Scans: {folder_status_count}")
            self.logger.info(f"üîç Consistency Check - Saved Scans: {saved_status_count}")
            
            # C·∫£nh b√°o n·∫øu c√≥ s·ª± kh√°c bi·ªát l·ªõn
            folder_uploaded = folder_status_count.get('uploaded', 0)
            saved_uploaded = saved_status_count.get('uploaded', 0)
            if abs(folder_uploaded - saved_uploaded) > 0:
                self.logger.warning(f"‚ö†Ô∏è Data inconsistency detected - Folder uploaded: {folder_uploaded}, Saved uploaded: {saved_uploaded}")
                
        except Exception as e:
            self.logger.error(f"Error in consistency check: {str(e)}")

    def load_batch_filter(self):
        """Load saved scans cho batch filter dropdown"""
        try:
            self.filter_batch_combo.clear()
            self.filter_batch_combo.addItem("T·∫•t c·∫£ d·ªØ li·ªáu", None)

            # Load saved scans
            saved_scans = self.db_manager.get_all_saved_scans()
            for scan in saved_scans:
                scan_name = scan.get('name', f"Scan {scan.get('id', '')}")
                folder_count = scan.get('folder_count', 0)
                display_name = f"üì¶ {scan_name} ({folder_count} folders)"
                self.filter_batch_combo.addItem(display_name, scan.get('id'))

        except Exception as e:
            self.logger.error(f"Error loading batch filter: {str(e)}")

    def load_upload_batch_selector(self):
        """Load saved scans cho upload batch selector"""
        try:
            if not hasattr(self, 'upload_batch_combo'):
                return

            self.upload_batch_combo.clear()
            self.upload_batch_combo.addItem("Ch·ªçn t·ª´ b·∫£ng chi ti·∫øt", None)

            # Load saved scans
            saved_scans = self.db_manager.get_all_saved_scans()
            for scan in saved_scans:
                scan_name = scan.get('name', f"Scan {scan.get('id', '')}")
                folder_count = scan.get('folder_count', 0)
                display_name = f"üì¶ {scan_name} ({folder_count} folders)"
                self.upload_batch_combo.addItem(display_name, scan.get('id'))

            # Connect signal ƒë·ªÉ enable/disable load batch button
            self.upload_batch_combo.currentTextChanged.connect(self.on_upload_batch_changed)

        except Exception as e:
            self.logger.error(f"Error loading upload batch selector: {str(e)}")

    def on_upload_batch_changed(self):
        """X·ª≠ l√Ω khi thay ƒë·ªïi batch selector"""
        try:
            batch_id = self.upload_batch_combo.currentData()
            self.load_batch_btn.setEnabled(batch_id is not None)

            # Hi·ªÉn th·ªã th·ªëng k√™ nhanh cho batch ƒë∆∞·ª£c ch·ªçn
            if batch_id and hasattr(self, 'upload_stats_label'):
                try:
                    saved_scans = self.db_manager.get_all_saved_scans()
                    selected_scan = None
                    for scan in saved_scans:
                        if scan.get('id') == batch_id:
                            selected_scan = scan
                            break

                    if selected_scan:
                        import json
                        data_json = selected_scan.get('data', '[]')
                        if isinstance(data_json, str):
                            folders_data = json.loads(data_json)
                        else:
                            folders_data = data_json

                        # ƒê·∫øm theo tr·∫°ng th√°i
                        pending_count = 0
                        completed_count = 0
                        uploaded_count = 0
                        error_count = 0

                        for folder in folders_data:
                            status = folder.get('status', 'pending')
                            if status == 'completed':
                                completed_count += 1
                            elif status == 'uploaded':
                                uploaded_count += 1
                            elif status == 'error':
                                error_count += 1
                            else:  # pending v√† c√°c status kh√°c
                                pending_count += 1

                        # Hi·ªÉn th·ªã th·ªëng k√™ r√µ r√†ng
                        total_count = len(folders_data)
                        stats_text = f"üìä T·ªïng: {total_count} | ‚è≥ Ch·ªù: {pending_count} | ‚úÖ Ho√†n th√†nh: {completed_count}"
                        if uploaded_count > 0:
                            stats_text += f" | üöÄ ƒê√£ ƒëƒÉng: {uploaded_count}"
                        if error_count > 0:
                            stats_text += f" | ‚ùå L·ªói: {error_count}"

                        self.upload_stats_label.setText(stats_text)
                    else:
                        self.upload_stats_label.setText("Kh√¥ng t√¨m th·∫•y batch")
                except Exception as e:
                    self.upload_stats_label.setText("L·ªói load th·ªëng k√™")
                    self.logger.error(f"Error loading batch stats: {str(e)}")
            else:
                if hasattr(self, 'upload_stats_label'):
                    self.upload_stats_label.setText("Ch·ªçn batch ƒë·ªÉ xem th·ªëng k√™")

        except Exception as e:
            self.logger.error(f"Error handling batch change: {str(e)}")

    def is_folder_already_processed(self, folder_data):
        """Ki·ªÉm tra xem folder ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω (upload) th√†nh c√¥ng ch∆∞a - Updated logic"""
        try:
            folder_id = folder_data.get('id')
            
            # Lu√¥n ki·ªÉm tra database tr∆∞·ªõc (source of truth)
            if folder_id and self.db_manager:
                try:
                    db_folder = self.db_manager.get_folder_scan_by_id(folder_id)
                    if db_folder:
                        # Sync folder_data v·ªõi database data
                        db_status = db_folder.get('status', 'pending')
                        db_upload_success = db_folder.get('upload_success', 0)
                        db_wc_product_id = db_folder.get('wc_product_id')
                        
                        # C·∫≠p nh·∫≠t folder_data v·ªõi th√¥ng tin m·ªõi nh·∫•t t·ª´ database
                        folder_data['status'] = db_status
                        folder_data['upload_success'] = db_upload_success
                        if db_wc_product_id:
                            folder_data['wc_product_id'] = db_wc_product_id
                        if db_folder.get('uploaded_at'):
                            folder_data['uploaded_at'] = db_folder.get('uploaded_at')
                        if db_folder.get('product_url'):
                            folder_data['product_url'] = db_folder.get('product_url')
                        
                        # Ki·ªÉm tra c√°c ƒëi·ªÅu ki·ªán processed d·ª±a tr√™n database
                        if db_upload_success == 1:
                            self.logger.debug(f"Folder {folder_id} ƒë√£ processed: upload_success = 1")
                            return True
                            
                        if db_wc_product_id and db_wc_product_id > 0:
                            self.logger.debug(f"Folder {folder_id} ƒë√£ processed: c√≥ wc_product_id = {db_wc_product_id}")
                            return True
                            
                        if db_status in ['uploaded']:  # Ch·ªâ 'uploaded' m·ªõi ƒë∆∞·ª£c coi l√† processed
                            self.logger.debug(f"Folder {folder_id} ƒë√£ processed: status = {db_status}")
                            return True
                            
                        # Log status cho debug
                        self.logger.debug(f"Folder {folder_id} ch∆∞a processed: status={db_status}, upload_success={db_upload_success}, wc_product_id={db_wc_product_id}")
                        return False
                        
                except Exception as e:
                    self.logger.warning(f"L·ªói ki·ªÉm tra database cho folder {folder_id}: {str(e)}")
                    # Fallback to folder_data check n·∫øu database l·ªói
                    pass

            # Fallback: ki·ªÉm tra t·ª´ folder_data n·∫øu kh√¥ng c√≥ database
            # Ki·ªÉm tra upload_success flag
            if folder_data.get('upload_success') == 1:
                self.logger.debug(f"Folder {folder_id} ƒë√£ processed (fallback): upload_success = 1")
                return True

            # Ki·ªÉm tra c√≥ wc_product_id kh√¥ng
            wc_product_id = folder_data.get('wc_product_id')
            if wc_product_id and wc_product_id > 0:
                self.logger.debug(f"Folder {folder_id} ƒë√£ processed (fallback): c√≥ wc_product_id = {wc_product_id}")
                return True

            # Ki·ªÉm tra status - ch·ªâ 'uploaded' m·ªõi ƒë∆∞·ª£c coi l√† processed
            status = folder_data.get('status', 'pending')
            if status == 'uploaded':
                self.logger.debug(f"Folder {folder_id} ƒë√£ processed (fallback): status = {status}")
                return True

            self.logger.debug(f"Folder {folder_id} ch∆∞a processed (fallback): status={status}, upload_success={folder_data.get('upload_success')}, wc_product_id={wc_product_id}")
            return False

        except Exception as e:
            self.logger.error(f"L·ªói ki·ªÉm tra folder processed: {str(e)}")
            return False

    def load_batch_upload_data(self):
        """Load to√†n b·ªô d·ªØ li·ªáu t·ª´ batch ƒë∆∞·ª£c ch·ªçn v√†o h√†ng ƒë·ª£i upload (ch·ªâ load tr·∫°ng th√°i pending)"""
        try:
            batch_id = self.upload_batch_combo.currentData()
            if not batch_id:
                QMessageBox.warning(self, "C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt batch!")
                return

            # T√¨m saved scan
            saved_scans = self.db_manager.get_all_saved_scans()
            selected_scan = None
            for scan in saved_scans:
                if scan.get('id') == batch_id:
                    selected_scan = scan
                    break

            if not selected_scan:
                QMessageBox.warning(self, "L·ªói", "Kh√¥ng t√¨m th·∫•y batch ƒë∆∞·ª£c ch·ªçn!")
                return

            # Track batch ID ƒë∆∞·ª£c load
            self.current_loaded_batch_id = selected_scan.get('id')

            # Load folders t·ª´ saved scan
            import json

            data_json = selected_scan.get('data', '[]')
            if isinstance(data_json, str):
                folders_data = json.loads(data_json)
            else:
                folders_data = data_json

            # Clear existing upload queue
            self.upload_folders = []
            self.upload_queue_table.setRowCount(0)

            # Ph√¢n lo·∫°i theo tr·∫°ng th√°i
            pending_count = 0
            completed_count = 0
            uploaded_count = 0
            error_count = 0
            loaded_count = 0

            for folder_data in folders_data:
                status = folder_data.get('status', 'pending')

                # ƒê·∫øm theo tr·∫°ng th√°i
                if status == 'completed':
                    completed_count += 1
                elif status == 'uploaded':
                    uploaded_count += 1
                elif status == 'error':
                    error_count += 1
                else:
                    pending_count += 1

                # Ch·ªâ load nh·ªØng folder c√≥ tr·∫°ng th√°i 'pending' (ch·ªù x·ª≠ l√Ω) v√† ch∆∞a ƒë∆∞·ª£c x·ª≠ l√Ω
                if status == 'pending' and not self.is_folder_already_processed(folder_data) and self.validate_folder_for_upload(folder_data):
                    self.upload_folders.append(folder_data)
                    self.add_folder_to_upload_queue(folder_data)
                    loaded_count += 1

            # T·∫°o th√¥ng b√°o chi ti·∫øt
            total_count = len(folders_data)
            actual_pending = len([f for f in folders_data if f.get('status', 'pending') == 'pending' and not self.is_folder_already_processed(f)])

            status_detail = f"üìä Th·ªëng k√™ batch '{selected_scan.get('name', '')}':\n"
            status_detail += f"‚Ä¢ T·ªïng s·ªë: {total_count} s·∫£n ph·∫©m\n"
            status_detail += f"‚Ä¢ ‚è≥ Ch·ªù x·ª≠ l√Ω th·ª±c t·∫ø: {actual_pending}\n"
            status_detail += f"‚Ä¢ ‚è≥ Ch·ªù x·ª≠ l√Ω (theo saved scan): {pending_count}\n"
            status_detail += f"‚Ä¢ ‚úÖ Ho√†n th√†nh: {completed_count}\n"
            if uploaded_count > 0:
                status_detail += f"‚Ä¢ üöÄ ƒê√£ ƒëƒÉng: {uploaded_count}\n"
            if error_count > 0:
                status_detail += f"‚Ä¢ ‚ùå L·ªói: {error_count}\n"
            status_detail += f"\nüì• ƒê√£ load {loaded_count}/{actual_pending} s·∫£n ph·∫©m th·ª±c s·ª± ch·ªù x·ª≠ l√Ω v√†o h√†ng ƒë·ª£i"

            # Enable buttons based on loaded folders
            if loaded_count > 0:
                self.config_upload_btn.setEnabled(True)
                self.start_upload_btn.setEnabled(True)
                self.upload_status_label.setText(f"‚úÖ ƒê√£ load {loaded_count} s·∫£n ph·∫©m ch·ªù x·ª≠ l√Ω t·ª´ batch v√†o h√†ng ƒë·ª£i")

                QMessageBox.information(
                    self, "Th√†nh c√¥ng", 
                    status_detail + "\n\n"
                    f"‚úÖ ƒê√£ load {loaded_count} s·∫£n ph·∫©m v√†o h√†ng ƒë·ª£i upload\n\n"
                    f"‚Ä¢ Nh·∫•n 'Thi·∫øt l·∫≠p c·∫•u h√¨nh ƒëƒÉng' ƒë·ªÉ c·∫•u h√¨nh chi ti·∫øt\n"
                    f"‚Ä¢ Nh·∫•n 'B·∫Øt ƒë·∫ßu ƒëƒÉng h√†ng lo·∫°t' ƒë·ªÉ upload v·ªõi c·∫•u h√¨nh m·∫∑c ƒë·ªãnh"
                )
            else:
                self.config_upload_btn.setEnabled(False)
                self.start_upload_btn.setEnabled(False)
                if pending_count == 0:
                    self.upload_status_label.setText(f"‚úÖ Batch ƒë√£ ho√†n th√†nh to√†n b·ªô ({completed_count + uploaded_count}/{total_count})")

                    QMessageBox.information(
                        self, "Th√¥ng b√°o", 
                        status_detail + "\n\n"
                        "üéâ Batch n√†y ƒë√£ ho√†n th√†nh to√†n b·ªô!\n"
                        "T·∫•t c·∫£ s·∫£n ph·∫©m ƒë·ªÅu ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω ho·∫∑c ƒëƒÉng th√†nh c√¥ng."
                    )
                else:
                    self.upload_status_label.setText(f"‚ö†Ô∏è Kh√¥ng load ƒë∆∞·ª£c s·∫£n ph·∫©m n√†o t·ª´ {pending_count} s·∫£n ph·∫©m ch·ªù x·ª≠ l√Ω")

                    QMessageBox.warning(
                        self, "C·∫£nh b√°o", 
                        status_detail + "\n\n"
                        f"‚ö†Ô∏è C√≥ {pending_count} s·∫£n ph·∫©m ch·ªù x·ª≠ l√Ω nh∆∞ng kh√¥ng th·ªÉ load v√†o h√†ng ƒë·ª£i.\n"
                        "C√≥ th·ªÉ do:\n"
                        "‚Ä¢ ƒê∆∞·ªùng d·∫´n folder kh√¥ng t·ªìn t·∫°i\n"
                        "‚Ä¢ Folder kh√¥ng c√≥ ·∫£nh h·ª£p l·ªá\n"
                        "‚Ä¢ Thi·∫øu t√™n s·∫£n ph·∫©m\n\n"
                        "Vui l√≤ng ki·ªÉm tra d·ªØ li·ªáu trong tab 'T·ªïng quan'."
                    )

        except Exception as e:
            self.logger.error(f"L·ªói load batch upload data: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ load d·ªØ li·ªáu batch: {str(e)}")

    def load_sites_filter(self):
        """Load sites cho filter dropdown"""
        try:
            self.filter_site_combo.clear()
            self.filter_site_combo.addItem("T·∫•t c·∫£ sites", None)

            sites = self.db_manager.get_all_sites()
            for site in sites:
                self.filter_site_combo.addItem(site.name, site.id)

        except Exception as e:
            self.logger.error(f"Error loading sites filter: {str(e)}")

    def load_detailed_data(self):
        """Load d·ªØ li·ªáu chi ti·∫øt v√†o b·∫£ng - bao g·ªìm c·∫£ saved scans v√† folder scans"""
        try:
            # Debouncing: tr√°nh g·ªçi li√™n ti·∫øp trong th·ªùi gian ng·∫Øn
            if hasattr(self, '_load_timer'):
                self._load_timer.stop()

            self._load_timer = QTimer()
            self._load_timer.setSingleShot(True)
            self._load_timer.timeout.connect(self._do_load_detailed_data)
            self._load_timer.start(100)  # Delay 100ms

        except Exception as e:
            self.logger.error(f"Error in load_detailed_data: {str(e)}")

    def _do_load_detailed_data(self):
        """Th·ª±c hi·ªán load d·ªØ li·ªáu chi ti·∫øt (debounced version)"""
        try:
            if not self.db_manager:
                self.logger.warning("Database manager not available")
                return

            # L·∫•y filter values
            batch_id = self.filter_batch_combo.currentData()
            site_id = self.filter_site_combo.currentData()
            status_filter = self.filter_status_combo.currentText()

            all_data = []

            if batch_id is None:
                # Hi·ªÉn th·ªã t·∫•t c·∫£ d·ªØ li·ªáu (saved scans + folder scans)
                # L·∫•y d·ªØ li·ªáu saved scans
                saved_scans = self.db_manager.get_all_saved_scans()

                # L·∫•y d·ªØ li·ªáu folder scans
                folder_scans = self.db_manager.get_all_folder_scans()

                self.logger.debug(f"Found {len(saved_scans)} saved scans and {len(folder_scans)} folder scans")

                # Th√™m saved scans v√†o ƒë·∫ßu danh s√°ch
                for scan in saved_scans:
                    all_data.append({
                        'type': 'saved_scan',
                        'id': scan.get('id'),
                        'name': scan.get('name', ''),
                        'description': scan.get('description', ''),
                        'folder_count': scan.get('folder_count', 0),
                        'created_at': scan.get('created_at', ''),
                        'data': scan  # L∆∞u to√†n b·ªô data
                    })

                # Th√™m individual folder scans
                for folder in folder_scans:
                    # Apply filters cho folder scans
                    if site_id and folder.get('site_id') != site_id:
                        continue
                    if status_filter != "T·∫•t c·∫£" and folder.get('status') != status_filter:
                        continue

                    all_data.append({
                        'type': 'folder_scan',
                        'id': folder.get('id'),
                        'name': folder.get('data_name') or folder.get('original_title', ''),
                        'description': f"Folder v·ªõi {folder.get('image_count', 0)} ·∫£nh" + (f" - {folder.get('site_name')}" if folder.get('site_name') else ""),
                        'folder_count': folder.get('image_count', 0),
                        'created_at': folder.get('created_at', ''),
                        'data': folder  # L∆∞u to√†n b·ªô data
                    })
            else:
                # Ch·ªâ hi·ªÉn th·ªã d·ªØ li·ªáu c·ªßa batch ƒë∆∞·ª£c ch·ªçn
                import json
                saved_scan = None
                saved_scans = self.db_manager.get_all_saved_scans()
                for scan in saved_scans:
                    if scan.get('id') == batch_id:
                        saved_scan = scan
                        break

                if saved_scan:
                    # Parse folder data t·ª´ saved scan
                    try:
                        data_json = saved_scan.get('data', '[]')
                        if isinstance(data_json, str):
                            folders_data = json.loads(data_json)
                        else:
                            folders_data = data_json

                        # Th√™m t·ª´ng folder t·ª´ batch v√†o all_data
                        for folder in folders_data:
                            # Apply filters cho folder scans
                            if site_id and folder.get('site_id') != site_id:
                                continue
                            if status_filter != "T·∫•t c·∫£" and folder.get('status') != status_filter:
                                continue

                            all_data.append({
                                'type': 'batch_folder',
                                'id': folder.get('id'),
                                'name': folder.get('data_name') or folder.get('original_title', ''),
                                'description': f"üì¶ Batch: {saved_scan.get('name', '')} - {folder.get('image_count', 0)} ·∫£nh" + (f" - {folder.get('site_name', '')}" if folder.get('site_name') else ""),
                                'folder_count': folder.get('image_count', 0),
                                'created_at': folder.get('created_at', ''),
                                'data': folder  # L∆∞u to√†n b·ªô data
                            })

                        self.logger.info(f"Loaded {len(all_data)} folders from batch: {saved_scan.get('name', '')}")
                    except Exception as e:
                        self.logger.error(f"Error parsing batch data: {str(e)}")
                else:
                    self.logger.warning(f"Batch with ID {batch_id} not found")

            # Populate table
            self.data_table.setRowCount(len(all_data))

            for row, item in enumerate(all_data):
                folder_data = item['data']

                # T√™n s·∫£n ph·∫©m (c·ªôt 0) - v·ªõi icon ƒë·ªÉ ph√¢n bi·ªát lo·∫°i
                name_text = item['name']
                if item['type'] == 'saved_scan':
                    name_text = f"üì¶ {name_text}"  # Icon cho saved scan
                elif item['type'] == 'batch_folder':
                    name_text = f"üì¶üìÅ {name_text}"  # Icon cho folder t·ª´ batch
                else:
                    name_text = f"üìÅ {name_text}"  # Icon cho folder scan

                name_item = QTableWidgetItem(name_text)
                name_item.setData(Qt.ItemDataRole.UserRole, item)  # L∆∞u to√†n b·ªô data
                self.data_table.setItem(row, 0, name_item)

                # S·ªë ·∫£nh (c·ªôt 1)
                image_count = folder_data.get('image_count', 0) if item['type'] == 'folder_scan' else item.get('folder_count', 0)
                self.data_table.setItem(row, 1, QTableWidgetItem(str(image_count)))

                # Site (c·ªôt 2)
                site_name = ""
                if item['type'] == 'folder_scan' or item['type'] == 'batch_folder':
                    site_id = folder_data.get('site_id')
                    if site_id and self.db_manager:
                        try:
                            sites = self.db_manager.get_all_sites()
                            for site in sites:
                                if site.id == site_id:
                                    site_name = site.name
                                    break
                        except:
                            pass
                    if not site_name:
                        site_name = folder_data.get('site_name', 'Ch∆∞a ch·ªçn')
                    if item['type'] == 'batch_folder':
                        site_name = f"üì¶ {site_name}"  # Th√™m icon batch
                elif item['type'] == 'saved_scan':
                    site_name = "T·ªïng h·ª£p"
                self.data_table.setItem(row, 2, QTableWidgetItem(site_name))

                # Danh m·ª•c (c·ªôt 3)
                category_name = ""
                if item['type'] == 'folder_scan' or item['type'] == 'batch_folder':
                    category_id = folder_data.get('category_id')
                    if category_id and self.db_manager:
                        try:
                            category = self.db_manager.get_category_by_id(category_id)
                            if category:
                                category_name = category.get('name', 'Ch∆∞a c√≥')
                        except:
                            pass
                    if not category_name:
                        category_name = folder_data.get('category_name', 'Ch∆∞a c√≥')
                    if item['type'] == 'batch_folder':
                        category_name = f"üì¶ {category_name}"  # Th√™m icon batch
                elif item['type'] == 'saved_scan':
                    category_name = "T·ªïng h·ª£p"
                self.data_table.setItem(row, 3, QTableWidgetItem(category_name))

                # Tr·∫°ng th√°i (c·ªôt 4)
                status_text = ""
                if item['type'] == 'folder_scan' or item['type'] == 'batch_folder':
                    status = folder_data.get('status', 'pending')
                    status_icons = {
                        'pending': '‚è≥ Ch·ªù x·ª≠ l√Ω',
                        'completed': '‚úÖ Ho√†n th√†nh',
                        'uploaded': 'üöÄ ƒê√£ ƒëƒÉng',
                        'failed': '‚ùå Th·∫•t b·∫°i'
                    }
                    status_text = status_icons.get(status, f"‚ùì {status}")
                    if item['type'] == 'batch_folder':
                        status_text = f"üì¶ {status_text}"  # Th√™m icon batch
                elif item['type'] == 'saved_scan':
                    status_text = "üìä Saved Scan"

                status_item = QTableWidgetItem(status_text)
                # Th√™m m√†u s·∫Øc cho tr·∫°ng th√°i
                if 'pending' in status_text.lower():
                    status_item.setBackground(QColor(255, 248, 220))  # V√†ng nh·∫°t
                elif 'ho√†n th√†nh' in status_text.lower():
                    status_item.setBackground(QColor(220, 255, 220))  # Xanh nh·∫°t
                elif 'ƒë√£ ƒëƒÉng' in status_text.lower():
                    status_item.setBackground(QColor(220, 220, 255))  # Xanh d∆∞∆°ng nh·∫°t
                elif 'th·∫•t b·∫°i' in status_text.lower():
                    status_item.setBackground(QColor(255, 220, 220))  # ƒê·ªè nh·∫°t
                self.data_table.setItem(row, 4, status_item)

                # Ng√†y t·∫°o (c·ªôt 5)
                created_at = item['created_at']
                if created_at:
                    try:
                        from datetime import datetime
                        if isinstance(created_at, str):
                            dt = datetime.fromisoformat(created_at.replace('Z', '+00:00'))
                            formatted_date = dt.strftime('%Y-%m-%d %H:%M')
                        else:
                            formatted_date = str(created_at)
                    except:
                        formatted_date = str(created_at)
                else:
                    formatted_date = ""
                self.data_table.setItem(row, 5, QTableWidgetItem(formatted_date))

                # Thao t√°c (c·ªôt 6) - Buttons cho c√°c h√†nh ƒë·ªông
                action_text = ""
                if item['type'] == 'folder_scan':
                    status = folder_data.get('status', 'pending')
                    if status == 'pending':
                        action_text = "üîß C·∫•u h√¨nh"
                    elif status == 'completed':
                        action_text = "üöÄ C√≥ th·ªÉ ƒëƒÉng"
                    elif status == 'uploaded':
                        action_text = "‚úÖ ƒê√£ ƒëƒÉng"
                    else:
                        action_text = "‚öôÔ∏è Xem chi ti·∫øt"
                else:
                    action_text = "üìã Load data"

                action_item = QTableWidgetItem(action_text)
                action_item.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
                self.data_table.setItem(row, 6, action_item)

            # Resize columns to content
            self.data_table.resizeColumnsToContents()

        except Exception as e:
            self.logger.error(f"Error loading detailed data: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ load d·ªØ li·ªáu chi ti·∫øt: {str(e)}")

    def preview_cleanup(self):
        """Xem tr∆∞·ªõc cleanup"""
        try:
            preview_text = "üìã XEM TR∆Ø·ªöC CLEANUP:\n\n"

            if self.orphaned_check.isChecked():
                # Count orphaned folders
                folders = self.db_manager.get_all_folder_scans()
                orphaned_count = 0
                for folder in folders:
                    if not os.path.exists(folder.get('path', '')):
                        orphaned_count += 1
                preview_text += f"‚Ä¢ S·∫Ω x√≥a {orphaned_count} folder scans kh√¥ng c√≤n t·ªìn t·∫°i\n"

            if self.duplicate_check.isChecked():
                duplicates = self.db_manager.get_duplicate_folder_scans()
                preview_text += f"‚Ä¢ S·∫Ω g·ªôp {len(duplicates)} nh√≥m folder scans tr√πng l·∫∑p\n"

            if self.missing_names_check.isChecked():
                folders = self.db_manager.get_all_folder_scans()
                missing_count = 0
                for folder in folders:
                    if not folder.get('data_name') or folder.get('data_name', '').strip() == '':
                        missing_count += 1
                preview_text += f"‚Ä¢ S·∫Ω s·ª≠a {missing_count} data_name tr·ªëng\n"

            if self.optimize_check.isChecked():
                preview_text += "‚Ä¢ S·∫Ω t·ªëi ∆∞u database\n"

            preview_text += "\n‚ö†Ô∏è Thao t√°c n√†y kh√¥ng th·ªÉ ho√†n t√°c!"

            QMessageBox.information(self, "Xem tr∆∞·ªõc Cleanup", preview_text)

        except Exception as e:
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ xem tr∆∞·ªõc: {str(e)}")

    def start_cleanup(self):
        """B·∫Øt ƒë·∫ßu cleanup"""
        try:
            # X√°c nh·∫≠n
            reply = QMessageBox.question(
                self, "X√°c nh·∫≠n", 
                "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën th·ª±c hi·ªán cleanup?\nThao t√°c n√†y kh√¥ng th·ªÉ ho√†n t√°c!",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )

            if reply != QMessageBox.StandardButton.Yes:
                return

            # Chu·∫©n b·ªã options
            cleanup_options = {
                'orphaned_folders': self.orphaned_check.isChecked(),
                'duplicate_folders': self.duplicate_check.isChecked(),
                'missing_data_names': self.missing_names_check.isChecked(),
                'optimize_db': self.optimize_check.isChecked()
            }

            if not any(cleanup_options.values()):
                QMessageBox.information(self, "Th√¥ng b√°o", "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt t√πy ch·ªçn cleanup!")
                return

            # Progress dialog
            self.progress_dialog = QProgressDialog("ƒêang cleanup...", "H·ªßy", 0, 100, self)
            self.progress_dialog.setWindowModality(Qt.WindowModality.WindowModal)
            self.progress_dialog.setMinimumDuration(0)
            self.progress_dialog.show()

            # Worker thread
            self.cleanup_worker = DataCleanupWorker(self.db_manager, cleanup_options)
            self.cleanup_worker.progress_update.connect(self.on_cleanup_progress)
            self.cleanup_worker.finished.connect(self.on_cleanup_finished)

            self.cleanup_btn.setEnabled(False)
            self.cleanup_worker.start()

        except Exception as e:
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu cleanup: {str(e)}")

    def on_cleanup_progress(self, percent, message):
        """C·∫≠p nh·∫≠t ti·∫øn ƒë·ªô cleanup"""
        if self.progress_dialog:
            self.progress_dialog.setValue(percent)
            self.progress_dialog.setLabelText(message)

    def on_cleanup_finished(self, success, message, results):
        """Ho√†n th√†nh cleanup"""
        try:
            if self.progress_dialog:
                self.progress_dialog.close()
                self.progress_dialog = None

            self.cleanup_btn.setEnabled(True)

            if success:
                # Hi·ªÉn th·ªã k·∫øt qu·∫£
                result_text = f"‚úÖ CLEANUP HO√ÄN TH√ÄNH!\n\n"
                result_text += f"üìä K·∫æT QU·∫¢:\n"

                if 'orphaned_deleted' in results:
                    result_text += f"‚Ä¢ ƒê√£ x√≥a {results['orphaned_deleted']} folder scans kh√¥ng c√≤n t·ªìn t·∫°i\n"

                if 'duplicates_found' in results:
                    result_text += f"‚Ä¢ T√¨m th·∫•y {results['duplicates_found']} nh√≥m tr√πng l·∫∑p\n"
                    if 'duplicates_merged' in results:
                        result_text += f"‚Ä¢ ƒê√£ g·ªôp {results['duplicates_merged']} nh√≥m tr√πng l·∫∑p\n"

                if 'data_names_fixed' in results:
                    result_text += f"‚Ä¢ ƒê√£ s·ª≠a {results['data_names_fixed']} data_name tr·ªëng\n"

                if results.get('db_optimized'):
                    result_text += f"‚Ä¢ ƒê√£ t·ªëi ∆∞u database\n"

                result_text += f"\nüïí Th·ªùi gian: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"

                self.cleanup_results.setPlainText(result_text)

                # Reload summary
                self.load_summary()

                QMessageBox.information(self, "Th√†nh c√¥ng", message)
            else:
                QMessageBox.critical(self, "L·ªói", message)

        except Exception as e:
            QMessageBox.critical(self, "L·ªói", f"L·ªói x·ª≠ l√Ω k·∫øt qu·∫£ cleanup: {str(e)}")

    def export_to_json(self):
        """Xu·∫•t d·ªØ li·ªáu ra JSON"""
        try:
            file_path, _ = QFileDialog.getSaveFileName(
                self, "Xu·∫•t JSON", f"folder_scans_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json",
                "JSON files (*.json)"
            )

            if file_path:
                exported_file = self.db_manager.export_folder_scans_to_json(file_path)
                QMessageBox.information(self, "Th√†nh c√¥ng", f"ƒê√£ xu·∫•t d·ªØ li·ªáu ra: {exported_file}")

        except Exception as e:
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ xu·∫•t JSON: {str(e)}")

    def export_to_csv(self):
        """Xu·∫•t d·ªØ li·ªáu ra CSV"""
        try:
            file_path, _ = QFileDialog.getSaveFileName(
                self, "Xu·∫•t CSV", f"folder_scans_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
                "CSV files (*.csv)"
            )

            if file_path:
                import csv
                folders = self.db_manager.get_all_folder_scans()

                with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
                    if folders:
                        fieldnames = folders[0].keys()
                        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                        writer.writeheader()
                        writer.writerows(folders)

                QMessageBox.information(self, "Th√†nh c√¥ng", f"ƒê√£ xu·∫•t {len(folders)} records ra: {file_path}")

        except Exception as e:
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ xu·∫•t CSV: {str(e)}")

    def backup_database(self):
        """Sao l∆∞u database"""
        try:
            import shutil

            file_path, _ = QFileDialog.getSaveFileName(
                self, "Sao l∆∞u Database", 
                f"woocommerce_manager_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db",
                "Database files (*.db)"
            )

            if file_path:
                shutil.copy2(self.db_manager.db_path, file_path)
                QMessageBox.information(self, "Th√†nh c√¥ng", f"ƒê√£ sao l∆∞u database ra: {file_path}")

        except Exception as e:
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ sao l∆∞u database: {str(e)}")

    def restore_database(self):
        """Kh√¥i ph·ª•c database"""
        try:
            file_path, _ = QFileDialog.getOpenFileName(
                self, "Kh√¥i ph·ª•c Database", "", "Database files (*.db)"
            )

            if file_path:
                reply = QMessageBox.question(
                    self, "X√°c nh·∫≠n", 
                    "Thao t√°c n√†y s·∫Ω ghi ƒë√® database hi·ªán t·∫°i!\nB·∫°n c√≥ ch·∫Øc ch·∫Øn?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.No
                )

                if reply == QMessageBox.StandardButton.Yes:
                    import shutil
                    shutil.copy2(file_path, self.db_manager.db_path)
                    QMessageBox.information(self, "Th√†nh c√¥ng", "ƒê√£ kh√¥i ph·ª•c database th√†nh c√¥ng!")
                    self.load_summary()

        except Exception as e:
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ kh√¥i ph·ª•c database: {str(e)}")

    def show_header_context_menu(self, position):
        """Hi·ªÉn th·ªã context menu cho header ƒë·ªÉ reset k√≠ch th∆∞·ªõc c·ªôt"""
        from PyQt6.QtWidgets import QMenu
        menu = QMenu(self)

        # Reset column sizes
        reset_action = menu.addAction("üîÑ Reset k√≠ch th∆∞·ªõc c·ªôt")
        reset_action.triggered.connect(self.reset_column_sizes)

        # Auto-fit columns
        autofit_action = menu.addAction("üìè T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh")
        autofit_action.triggered.connect(self.auto_fit_columns)

        # Save column layout
        save_layout_action = menu.addAction("üíæ L∆∞u layout")
        save_layout_action.triggered.connect(self.save_column_layout)

        # Load column layout
        load_layout_action = menu.addAction("üìÇ T·∫£i layout")
        load_layout_action.triggered.connect(self.load_column_layout)

        # Show menu
        header = self.data_table.horizontalHeader()
        menu.exec(header.mapToGlobal(position))

    def reset_column_sizes(self):
        """Reset k√≠ch th∆∞·ªõc c·ªôt v·ªÅ m·∫∑c ƒë·ªãnh"""
        try:
            # Thi·∫øt l·∫≠p l·∫°i resize modes
            header = self.data_table.horizontalHeader()
            resize_modes = [
                QHeaderView.ResizeMode.Stretch,           # T√™n
                QHeaderView.ResizeMode.Stretch,           # M√¥ t·∫£
                QHeaderView.ResizeMode.Fixed,             # S·ªë th∆∞ m·ª•c
                QHeaderView.ResizeMode.Fixed              # Ng√†y t·∫°o
            ]

            for col, mode in enumerate(resize_modes):
                if col < self.data_table.columnCount():
                    header.setSectionResizeMode(col, mode)

            # Reset width cho c√°c c·ªôt Fixed
            self.data_table.setColumnWidth(2, 100)   # S·ªë th∆∞ m·ª•c
            self.data_table.setColumnWidth(3, 150)   # Ng√†y t·∫°o

            QMessageBox.information(self, "Th√†nh c√¥ng", "ƒê√£ reset k√≠ch th∆∞·ªõc c·ªôt v·ªÅ m·∫∑c ƒë·ªãnh")

        except Exception as e:
            self.logger.error(f"L·ªói khi reset column sizes: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ reset k√≠ch th∆∞·ªõc c·ªôt: {str(e)}")

    def auto_fit_columns(self):
        """T·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc c·ªôt theo n·ªôi dung"""
        try:
            header = self.data_table.horizontalHeader()
            for col in range(self.data_table.columnCount()):
                # Ch·ªâ auto-fit c√°c c·ªôt c√≥ th·ªÉ resize
                if header.sectionResizeMode(col) in [
                    QHeaderView.ResizeMode.Interactive,
                    QHeaderView.ResizeMode.ResizeToContents
                ]:
                    self.data_table.resizeColumnToContents(col)

            QMessageBox.information(self, "Th√†nh c√¥ng", "ƒê√£ t·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc c·ªôt")

        except Exception as e:
            self.logger.error(f"L·ªói khi auto-fit columns: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ t·ª± ƒë·ªông ƒëi·ªÅu ch·ªânh: {str(e)}")

    def save_column_layout(self):
        """L∆∞u layout c·ªôt hi·ªán t·∫°i"""
        try:
            column_widths = []
            column_order = []

            header = self.data_table.horizontalHeader()

            # L∆∞u ƒë·ªô r·ªông c·ªôt
            for col in range(self.data_table.columnCount()):
                column_widths.append(self.data_table.columnWidth(col))

            # L∆∞u th·ª© t·ª± c·ªôt (logical index)
            for visual_index in range(header.count()):
                logical_index = header.logicalIndex(visual_index)
                column_order.append(logical_index)

            # L∆∞u v√†o bi·∫øn instance (c√≥ th·ªÉ m·ªü r·ªông ƒë·ªÉ l∆∞u v√†o file config)
            self.saved_column_widths = column_widths
            self.saved_column_order = column_order

            QMessageBox.information(self, "Th√†nh c√¥ng", "ƒê√£ l∆∞u layout c·ªôt")

        except Exception as e:
            self.logger.error(f"L·ªói khi save column layout: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ l∆∞u layout: {str(e)}")

    def load_column_layout(self):
        """T·∫£i layout c·ªôt ƒë√£ l∆∞u"""
        try:
            if not hasattr(self, 'saved_column_widths') or not hasattr(self, 'saved_column_order'):
                QMessageBox.information(self, "Th√¥ng b√°o", "Ch∆∞a c√≥ layout n√†o ƒë∆∞·ª£c l∆∞u!")
                return

            header = self.data_table.horizontalHeader()

            # Kh√¥i ph·ª•c th·ª© t·ª± c·ªôt
            for visual_index, logical_index in enumerate(self.saved_column_order):
                if visual_index < header.count() and logical_index < header.count():
                    current_visual = header.visualIndex(logical_index)
                    if current_visual != visual_index:
                        header.moveSection(current_visual, visual_index)

            # Kh√¥i ph·ª•c ƒë·ªô r·ªông c·ªôt
            for col, width in enumerate(self.saved_column_widths):
                if col < self.data_table.columnCount():
                    self.data_table.setColumnWidth(col, width)

            QMessageBox.information(self, "Th√†nh c√¥ng", "ƒê√£ t·∫£i layout c·ªôt")

        except Exception as e:
            self.logger.error(f"L·ªói khi load column layout: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ t·∫£i layout: {str(e)}")

    def on_data_selection_changed(self):
        """X·ª≠ l√Ω khi selection data table thay ƒë·ªïi"""
        has_selection = len(self.data_table.selectedItems()) > 0
        self.edit_data_btn.setEnabled(has_selection)
        self.delete_data_btn.setEnabled(has_selection)
        self.view_details_btn.setEnabled(has_selection)

    def get_selected_folder_data(self):
        """L·∫•y data ƒë∆∞·ª£c ch·ªçn (c√≥ th·ªÉ l√† saved scan ho·∫∑c folder scan)"""
        current_row = self.data_table.currentRow()
        if current_row < 0:
            return None

        # L·∫•y data t·ª´ c·ªôt T√™n (UserRole)
        name_item = self.data_table.item(current_row, 0)
        if name_item:
            selected_item = name_item.data(Qt.ItemDataRole.UserRole)
            return selected_item
        return None

    def edit_selected_data(self):
        """Ch·ªânh s·ª≠a data ƒë∆∞·ª£c ch·ªçn"""
        try:
            folder_data = self.get_selected_folder_data()
            if not folder_data:
                QMessageBox.warning(self, "C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt item ƒë·ªÉ ch·ªânh s·ª≠a!")
                return

            # T·∫°o dialog ch·ªânh s·ª≠a
            dialog = DataEditDialog(self, folder_data)
            if dialog.exec() == QDialog.DialogCode.Accepted:
                updated_data = dialog.get_updated_data()

                # C·∫≠p nh·∫≠t v√†o database
                if self.db_manager.update_folder_scan(folder_data['id'], updated_data):
                    QMessageBox.information(self, "Th√†nh c√¥ng", "ƒê√£ c·∫≠p nh·∫≠t d·ªØ li·ªáu th√†nh c√¥ng!")
                    self.load_detailed_data()
                    self.load_summary()
                else:
                    QMessageBox.critical(self, "L·ªói", "Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t d·ªØ li·ªáu!")

        except Exception as e:
            self.logger.error(f"L·ªói khi ch·ªânh s·ª≠a data: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ ch·ªânh s·ª≠a data: {str(e)}")

    def delete_selected_data_batch(self):
        """X√≥a data ƒë∆∞·ª£c ch·ªçn (h·ªó tr·ª£ batch delete)"""
        try:
            # L·∫•y t·∫•t c·∫£ rows ƒë∆∞·ª£c ch·ªçn
            selected_rows = set()
            for item in self.data_table.selectedItems():
                selected_rows.add(item.row())

            if not selected_rows:
                QMessageBox.warning(self, "C·∫£nh b√°o", "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt item ƒë·ªÉ x√≥a!")
                return

            # L·∫•y danh s√°ch folder_data ƒë·ªÉ x√≥a
            folders_to_delete = []
            for row in selected_rows:
                try:
                    item = self.data_table.item(row, 0)
                    if item:
                        item_data = item.data(Qt.ItemDataRole.UserRole)
                        if item_data and item_data.get('type') == 'folder_scan':
                            folder_data = item_data.get('data', {})
                            if folder_data.get('id'):
                                folders_to_delete.append(folder_data)
                except Exception as e:
                    self.logger.warning(f"L·ªói l·∫•y data row {row}: {str(e)}")
                    continue

            if not folders_to_delete:
                QMessageBox.warning(self, "C·∫£nh b√°o", "Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu h·ª£p l·ªá ƒë·ªÉ x√≥a!")
                return

            # X√°c nh·∫≠n x√≥a
            count = len(folders_to_delete)
            if count == 1:
                data_name = folders_to_delete[0].get('data_name') or folders_to_delete[0].get('original_title', 'N/A')
                message = f"B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a data '{data_name}'?"
            else:
                message = f"B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a {count} items ƒë∆∞·ª£c ch·ªçn?"

            reply = QMessageBox.question(
                self, "X√°c nh·∫≠n x√≥a", 
                f"{message}\n\nThao t√°c n√†y kh√¥ng th·ªÉ ho√†n t√°c!",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                # X√≥a t·ª´ng folder
                deleted_count = 0
                failed_count = 0

                for folder_data in folders_to_delete:
                    try:
                        if self.db_manager.delete_folder_scan(folder_data['id']):
                            deleted_count += 1
                        else:
                            failed_count += 1
                    except Exception as e:
                        self.logger.error(f"L·ªói x√≥a folder {folder_data.get('id')}: {str(e)}")
                        failed_count += 1

                # Th√¥ng b√°o k·∫øt qu·∫£
                if deleted_count > 0:
                    if failed_count == 0:
                        QMessageBox.information(self, "Th√†nh c√¥ng", f"ƒê√£ x√≥a th√†nh c√¥ng {deleted_count} items!")
                    else:
                        QMessageBox.warning(self, "M·ªôt ph·∫ßn th√†nh c√¥ng", 
                                          f"ƒê√£ x√≥a {deleted_count} items, {failed_count} items th·∫•t b·∫°i!")

                    # Refresh data
                    self.load_detailed_data()
                    self.load_summary()
                else:
                    QMessageBox.critical(self, "L·ªói", "Kh√¥ng th·ªÉ x√≥a b·∫•t k·ª≥ d·ªØ li·ªáu n√†o!")

        except Exception as e:
            self.logger.error(f"L·ªói khi x√≥a data batch: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ x√≥a data: {str(e)}")

    def delete_selected_data(self):
        """X√≥a data ƒë∆∞·ª£c ch·ªçn (legacy function for compatibility)"""
        self.delete_selected_data_batch()

    def view_data_details(self):
        """Xem chi ti·∫øt data ƒë∆∞·ª£c ch·ªçn"""
        try:
            selected_item = self.get_selected_folder_data()
            if not selected_item:
                QMessageBox.warning(self, "C·∫£nh b√°o", "Vui l√≤ng ch·ªçn m·ªôt item ƒë·ªÉ xem chi ti·∫øt!")
                return

            # L·∫•y data th·ª±c t·∫ø ƒë·ªÉ hi·ªÉn th·ªã
            display_data = selected_item.get('data', selected_item)

            dialog = DataDetailsDialog(self, display_data, selected_item.get('type', 'unknown'))
            dialog.exec()

        except Exception as e:
            self.logger.error(f"L·ªói khi xem chi ti·∫øt data: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ xem chi ti·∫øt data: {str(e)}")

    def load_folders_from_saved_scan(self, saved_scan_item):
        """Load c√°c folders t·ª´ saved scan data"""
        try:
            import json

            saved_scan_data = saved_scan_item.get('data', {})
            data_json = saved_scan_data.get('data', '[]')

            # Parse JSON data
            if isinstance(data_json, str):
                folders_data = json.loads(data_json)
            else:
                folders_data = data_json

            loaded_count = 0
            for folder_data in folders_data:
                if self.validate_folder_for_upload(folder_data):
                    if folder_data not in self.upload_folders:
                        self.upload_folders.append(folder_data)
                        self.add_folder_to_upload_queue(folder_data)
                        loaded_count += 1

            self.logger.info(f"Loaded {loaded_count} folders from saved scan '{saved_scan_data.get('name', '')}'")

        except Exception as e:
            self.logger.error(f"L·ªói khi load folders t·ª´ saved scan: {str(e)}")
            QMessageBox.warning(self, "L·ªói", f"Kh√¥ng th·ªÉ load d·ªØ li·ªáu t·ª´ saved scan: {str(e)}")

    def validate_folder_for_upload(self, folder):
        """Ki·ªÉm tra folder c√≥ h·ª£p l·ªá ƒë·ªÉ upload kh√¥ng"""
        try:
            # Ki·ªÉm tra tr·∫°ng th√°i - ch·ªâ cho ph√©p 'pending'
            status = folder.get('status', 'pending')
            if status != 'pending':
                return False

            # Ki·ªÉm tra ƒë∆∞·ªùng d·∫´n t·ªìn t·∫°i
            folder_path = folder.get('path', '')
            if not folder_path or not os.path.exists(folder_path):
                return False

            # Ki·ªÉm tra c√≥ ·∫£nh kh√¥ng
            image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'}
            has_images = False

            try:
                for file in os.listdir(folder_path):
                    if any(file.lower().endswith(ext) for ext in image_extensions):
                        has_images = True
                        break
            except (OSError, PermissionError):
                return False

            # Ki·ªÉm tra c√≥ t√™n s·∫£n ph·∫©m kh√¥ng
            product_name = folder.get('new_title') or folder.get('data_name') or folder.get('original_title')
            if not product_name or not product_name.strip():
                return False

            return has_images

        except Exception as e:
            self.logger.error(f"L·ªói validate folder: {str(e)}")
            return False

    def add_folder_to_upload_queue(self, folder):
        """Th√™m m·ªôt folder v√†o h√†ng ƒë·ª£i upload table"""
        try:
            row_count = self.upload_queue_table.rowCount()
            self.upload_queue_table.insertRow(row_count)

            # Product name (column 0)
            data_name = folder.get('new_title') or folder.get('data_name') or folder.get('original_title', 'Untitled')
            name_item = QTableWidgetItem(data_name)
            name_item.setData(Qt.ItemDataRole.UserRole, folder)  # Store folder data
            self.upload_queue_table.setItem(row_count, 0, name_item)

            # Path (column 1) - r√∫t g·ªçn ƒë∆∞·ªùng d·∫´n n·∫øu qu√° d√†i
            path = folder.get('path', '')
            if len(path) > 50:
                path = "..." + path[-47:]
            self.upload_queue_table.setItem(row_count, 1, QTableWidgetItem(path))

            # Image count (column 2)
            image_count = str(folder.get('image_count', 0))
            self.upload_queue_table.setItem(row_count, 2, QTableWidgetItem(image_count))

            # Category (column 3) - l·∫•y t√™n danh m·ª•c
            category_name = "Ch∆∞a c√≥"
            category_id = folder.get('category_id')
            if category_id and self.db_manager:
                try:
                    category = self.db_manager.get_category_by_id(category_id)
                    if category:
                        category_name = category.get('name', 'Ch∆∞a c√≥')
                except:
                    pass
            elif folder.get('category_name'):
                category_name = folder.get('category_name')
            self.upload_queue_table.setItem(row_count, 3, QTableWidgetItem(str(category_name)))

            # Description (column 4) - m√¥ t·∫£ ng·∫Øn g·ªçn
            description = folder.get('description', '')
            if not description:
                description = f"Premium quality {data_name}"
            if len(description) > 50:
                description = description[:50] + "..."
            self.upload_queue_table.setItem(row_count, 4, QTableWidgetItem(str(description)))

            # Site (column 5) - t√™n site ƒëƒÉng
            site_name = "Ch∆∞a ch·ªçn"
            site_id = folder.get('site_id')
            if site_id and self.db_manager:
                try:
                    sites = self.db_manager.get_all_sites()
                    for site in sites:
                        if site.id == site_id:
                            site_name = site.name
                            break
                except:
                    pass
            elif folder.get('site_name'):
                site_name = folder.get('site_name')
            self.upload_queue_table.setItem(row_count, 5, QTableWidgetItem(str(site_name)))

            # Status (column 6) - initial status v·ªõi m√†u s·∫Øc
            status_item = QTableWidgetItem("‚è≥ Ch·ªù ƒëƒÉng")
            status_item.setBackground(QColor(255, 248, 220))  # Light yellow
            self.upload_queue_table.setItem(row_count, 6, status_item)

        except Exception as e:
            self.logger.error(f"L·ªói khi th√™m folder v√†o queue: {str(e)}")

    def on_queue_selection_changed(self):
        """X·ª≠ l√Ω khi selection trong upload queue thay ƒë·ªïi"""
        try:
            has_selection = len(self.upload_queue_table.selectedItems()) > 0
            self.remove_selected_btn.setEnabled(has_selection and len(self.upload_folders) > 0)
        except Exception as e:
            self.logger.error(f"L·ªói queue selection changed: {str(e)}")

    def show_upload_config(self):
        """Hi·ªÉn th·ªã dialog c·∫•u h√¨nh upload b·∫±ng ProductUploadDialog"""
        try:
            # Import ProductUploadDialog 
            from .product_upload_dialog import ProductUploadDialog

            dialog = ProductUploadDialog(
                parent=self,
                sites=self.db_manager.get_active_sites(),
                db_manager=self.db_manager,
                selected_folders=self.upload_folders
            )

            # K·∫øt n·ªëi signal product_uploaded
            dialog.product_uploaded.connect(self.on_product_uploaded_from_dialog)

            if dialog.exec() == QDialog.DialogCode.Accepted:
                # L∆∞u c·∫•u h√¨nh t·ª´ dialog
                if hasattr(dialog, 'saved_bulk_config') and dialog.saved_bulk_config:
                    self.save_upload_config(dialog.saved_bulk_config)
                elif hasattr(dialog, 'bulk_site_combo'):
                    # T·ª± ƒë·ªông l∆∞u c·∫•u h√¨nh t·ª´ dialog controls
                    auto_config = {
                        'site_id': dialog.bulk_site_combo.currentData(),
                        'category_id': dialog.bulk_category_combo.currentData() if hasattr(dialog, 'bulk_category_combo') else None,
                        'status': dialog.bulk_status_combo.currentText() if hasattr(dialog, 'bulk_status_combo') else 'draft',
                        'price': dialog.bulk_regular_price.value() if hasattr(dialog, 'bulk_regular_price') else 25.0,
                        'delay': dialog.upload_delay.value() if hasattr(dialog, 'upload_delay') else 3
                    }
                    self.save_upload_config(auto_config)

                # Upload th√†nh c√¥ng, clear queue v√† refresh data
                self.upload_folders = []
                self.upload_queue_table.setRowCount(0)
                self.config_upload_btn.setEnabled(False)
                self.start_upload_btn.setEnabled(False)
                self.upload_status_label.setText("Upload ho√†n th√†nh, ƒë√£ clear h√†ng ƒë·ª£i")

                # Refresh data trong b·∫£ng chi ti·∫øt
                self.load_detailed_data()
                self.load_summary()

                QMessageBox.information(
                    self, "Th√†nh c√¥ng", 
                    "ƒê√£ ho√†n th√†nh upload s·∫£n ph·∫©m!\n"
                    "D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong database."
                )
            else:
                # User cancel ho·∫∑c c√≥ l·ªói - v·∫´n l∆∞u c·∫•u h√¨nh n·∫øu c√≥
                if hasattr(dialog, 'saved_bulk_config') and dialog.saved_bulk_config:
                    self.save_upload_config(dialog.saved_bulk_config)
                self.upload_status_label.setText("ƒê√£ h·ªßy upload, d·ªØ li·ªáu v·∫´n trong h√†ng ƒë·ª£i")

        except Exception as e:
            self.logger.error(f"L·ªói khi hi·ªÉn th·ªã dialog upload: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ hi·ªÉn th·ªã dialog upload: {str(e)}")

    def pause_upload(self):
        """T·∫°m d·ª´ng upload"""
        try:
            # Placeholder for pause functionality
            self.upload_status_label.setText("‚è∏Ô∏è Upload ƒë√£ t·∫°m d·ª´ng")
            self.pause_upload_btn.setEnabled(False)
            self.resume_upload_btn.setEnabled(True)
            self.resume_upload_btn.setVisible(True)
            self.logger.info("Upload paused")
        except Exception as e:
            self.logger.error(f"Error pausing upload: {str(e)}")

    def resume_upload(self):
        """Ti·∫øp t·ª•c upload"""
        try:
            # Placeholder for resume functionality
            self.upload_status_label.setText("‚ñ∂Ô∏è Upload ƒë√£ ti·∫øp t·ª•c")
            self.pause_upload_btn.setEnabled(True)
            self.resume_upload_btn.setEnabled(False)
            self.resume_upload_btn.setVisible(False)
            self.logger.info("Upload resumed")
        except Exception as e:
            self.logger.error(f"Error resuming upload: {str(e)}")

    def stop_upload(self):
        """D·ª´ng upload"""
        try:
            reply = QMessageBox.question(
                self, "X√°c nh·∫≠n", 
                "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën d·ª´ng upload?\nTi·∫øn tr√¨nh hi·ªán t·∫°i s·∫Ω b·ªã h·ªßy.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                self.upload_status_label.setText("‚èπÔ∏è Upload ƒë√£ d·ª´ng")
                self.pause_upload_btn.setEnabled(False)
                self.resume_upload_btn.setEnabled(False)
                self.resume_upload_btn.setVisible(False)
                self.stop_upload_btn.setEnabled(False)
                self.start_upload_btn.setEnabled(True)
                self.logger.info("Upload stopped")
                
        except Exception as e:
            self.logger.error(f"Error stopping upload: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ d·ª´ng upload: {str(e)}")

    def on_product_uploaded_from_dialog(self, product_result):
        """X·ª≠ l√Ω khi c√≥ s·∫£n ph·∫©m ƒë∆∞·ª£c upload th√†nh c√¥ng t·ª´ dialog"""
        try:
            product_id = product_result.get('id')
            product_name = product_result.get('name', 'Unknown')

            self.logger.info(f"S·∫£n ph·∫©m ƒë∆∞·ª£c upload: {product_name} (ID: {product_id})")

            # C√≥ th·ªÉ th√™m logic c·∫≠p nh·∫≠t tr·∫°ng th√°i trong queue table ·ªü ƒë√¢y

        except Exception as e:
            self.logger.error(f"L·ªói x·ª≠ l√Ω product uploaded signal: {str(e)}")

    def save_upload_config(self, config):
        """L∆∞u c·∫•u h√¨nh upload"""
        try:
            # M·ªü r·ªông config ƒë·ªÉ l∆∞u th√™m th√¥ng tin
            enhanced_config = {
                'configured': True,
                'site_id': config.get('site_id'),
                'category_id': config.get('category_id'), 
                'status': config.get('status', 'draft'),
                'price': config.get('price', 25.0),
                'delay': config.get('delay', 3),
                'image_gallery': config.get('image_gallery', True),
                'auto_description': config.get('auto_description', True),
                'last_updated': datetime.now().isoformat()
            }

            self.upload_config = enhanced_config
            self.logger.info("ƒê√£ l∆∞u c·∫•u h√¨nh upload th√†nh c√¥ng v·ªõi th√¥ng tin m·ªü r·ªông")

            # Update UI status
            if hasattr(self, 'upload_status_label'):
                self.upload_status_label.setText("C·∫•u h√¨nh ƒë√£ ƒë∆∞·ª£c l∆∞u - s·∫µn s√†ng upload t·ª± ƒë·ªông")

            return True
        except Exception as e:
            self.logger.error(f"L·ªói l∆∞u c·∫•u h√¨nh upload: {str(e)}")
            return False

    def show_saved_scans_dialog(self):
        """Hi·ªÉn th·ªã dialog ƒë·ªÉ ch·ªçn v√† load saved scans"""
        try:
            saved_scans = self.db_manager.get_all_saved_scans()
            if not saved_scans:
                QMessageBox.information(self, "Th√¥ng b√°o", "Kh√¥ng c√≥ saved scans n√†o!\nVui l√≤ng qu√©t th∆∞ m·ª•c v√† l∆∞u k·∫øt qu·∫£ tr∆∞·ªõc.")
                return

            # T·∫°o dialog ch·ªçn saved scan
            dialog = QDialog(self)
            dialog.setWindowTitle("üì¶ Ch·ªçn Saved Scan ƒë·ªÉ Load")
            dialog.setModal(True)
            dialog.resize(800, 500)

            layout = QVBoxLayout(dialog)

            # Th√¥ng tin
            info_label = QLabel("Ch·ªçn m·ªôt ho·∫∑c nhi·ªÅu saved scans ƒë·ªÉ load v√†o qu·∫£n l√Ω:")
            info_label.setFont(QFont("Arial", 10, QFont.Weight.Bold))
            layout.addWidget(info_label)

            # Table hi·ªÉn th·ªã saved scans
            table = QTableWidget()
            table.setColumnCount(5)
            table.setHorizontalHeaderLabels(["Ch·ªçn", "T√™n", "M√¥ t·∫£", "S·ªë th∆∞ m·ª•c", "Ng√†y t·∫°o"])
            table.setRowCount(len(saved_scans))
            table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)

            for i, scan in enumerate(saved_scans):
                # Checkbox
                checkbox = QCheckBox()
                table.setCellWidget(i, 0, checkbox)

                # Data
                table.setItem(i, 1, QTableWidgetItem(scan.get('name', '')))
                table.setItem(i, 2, QTableWidgetItem(scan.get('description', '')))
                table.setItem(i, 3, QTableWidgetItem(str(scan.get('folder_count', 0))))
                table.setItem(i, 4, QTableWidgetItem(str(scan.get('created_at', ''))))

                # L∆∞u data v√†o item
                table.item(i, 1).setData(Qt.ItemDataRole.UserRole, scan)

            table.resizeColumnsToContents()
            table.setColumnWidth(0, 60)  # Checkbox column
            layout.addWidget(table)

            # Buttons
            button_layout = QHBoxLayout()

            select_all_btn = QPushButton("‚òëÔ∏è Ch·ªçn t·∫•t c·∫£")
            select_all_btn.clicked.connect(lambda: self.toggle_all_checkboxes(table, True))
            button_layout.addWidget(select_all_btn)

            deselect_all_btn = QPushButton("‚òê B·ªè ch·ªçn t·∫•t c·∫£")
            deselect_all_btn.clicked.connect(lambda: self.toggle_all_checkboxes(table, False))
            button_layout.addWidget(deselect_all_btn)

            button_layout.addStretch()

            load_btn = QPushButton("üìã Load ƒë√£ ch·ªçn")
            load_btn.setStyleSheet("""
                QPushButton {
                    background-color: #007bff;
                    color: white;
                    font-weight: bold;
                    padding: 8px 16px;
                    border: none;
                    border-radius: 4px;
                }
                QPushButton:hover {
                    background-color: #0056b3;
                }
            """)
            load_btn.clicked.connect(lambda: self.load_selected_saved_scans(dialog, table))
            button_layout.addWidget(load_btn)

            cancel_btn = QPushButton("‚ùå H·ªßy")
            cancel_btn.clicked.connect(dialog.reject)
            button_layout.addWidget(cancel_btn)

            layout.addLayout(button_layout)

            dialog.exec()

        except Exception as e:
            self.logger.error(f"L·ªói hi·ªÉn th·ªã saved scans dialog: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ hi·ªÉn th·ªã saved scans: {str(e)}")

    def toggle_all_checkboxes(self, table, checked_state):
        """Toggle t·∫•t c·∫£ checkboxes trong table"""
        try:
            for row in range(table.rowCount()):
                checkbox = table.cellWidget(row, 0)
                if checkbox:
                    checkbox.setChecked(checked_state)
        except Exception as e:
            self.logger.error(f"L·ªói toggle checkboxes: {str(e)}")

    def load_selected_saved_scans(self, dialog, table):
        """Load c√°c saved scans ƒë√£ ch·ªçn"""
        try:
            import json
            selected_scans = []

            # Collect selected scans
            for row in range(table.rowCount()):
                checkbox = table.cellWidget(row, 0)
                if checkbox and checkbox.isChecked():
                    scan_data = table.item(row, 1).data(Qt.ItemDataRole.UserRole)
                    if scan_data:
                        selected_scans.append(scan_data)

            if not selected_scans:
                QMessageBox.warning(dialog, "C·∫£nh b√°o", "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt saved scan!")
                return

            # Load folders t·ª´ selected scans
            total_loaded = 0
            for scan in selected_scans:
                try:
                    data_json = scan.get('data', '[]')
                    if isinstance(data_json, str):
                        folders_data = json.loads(data_json)
                    else:
                        folders_data = data_json

                    # Load t·ª´ng folder v√†o database n·∫øu ch∆∞a t·ªìn t·∫°i
                    for folder_data in folders_data:
                        path = folder_data.get('path', '')
                        if path:
                            # Ki·ªÉm tra ƒë√£ t·ªìn t·∫°i ch∆∞a
                            existing = self.db_manager.get_folder_scan_by_path(path)
                            if not existing:
                                # T·∫°o m·ªõi
                                self.db_manager.create_folder_scan(folder_data)
                                total_loaded += 1
                            else:
                                # C·∫≠p nh·∫≠t n·∫øu c·∫ßn thi·∫øt
                                self.db_manager.update_folder_scan(existing['id'], folder_data)

                except Exception as e:
                    self.logger.error(f"L·ªói load scan '{scan.get('name', '')}': {str(e)}")
                    continue

            # Refresh data
            self.load_detailed_data()
            self.load_summary()

            dialog.accept()

            QMessageBox.information(
                self, "Th√†nh c√¥ng", 
                f"ƒê√£ load {total_loaded} folder m·ªõi t·ª´ {len(selected_scans)} saved scans!\n"
                f"D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong b·∫£ng qu·∫£n l√Ω."
            )

        except Exception as e:
            self.logger.error(f"L·ªói load selected saved scans: {str(e)}")
            QMessageBox.critical(dialog, "L·ªói", f"Kh√¥ng th·ªÉ load saved scans: {str(e)}")

    def start_upload_scheduler(self):
        """B·∫Øt ƒë·∫ßu upload v·ªõi c·∫•u h√¨nh ƒë√£ thi·∫øt l·∫≠p - t·ª± ƒë·ªông load v√† upload"""
        try:
            if not self.upload_folders:
                QMessageBox.warning(self, "C·∫£nh b√°o", "Kh√¥ng c√≥ folder n√†o ƒë·ªÉ upload!")
                return

            # Ki·ªÉm tra c√≥ c·∫•u h√¨nh default kh√¥ng
            if not self.upload_config.get('configured', False):
                # Hi·ªÉn th·ªã dialog c·∫•u h√¨nh tr∆∞·ªõc
                reply = QMessageBox.question(
                    self, "C·∫•u h√¨nh upload", 
                    "Ch∆∞a c√≥ c·∫•u h√¨nh upload. B·∫°n c√≥ mu·ªën thi·∫øt l·∫≠p tr∆∞·ªõc kh√¥ng?",
                    QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                    QMessageBox.StandardButton.Yes
                )

                if reply == QMessageBox.StandardButton.Yes:
                    self.show_upload_config()
                    return
                else:
                    # S·ª≠ d·ª•ng c·∫•u h√¨nh m·∫∑c ƒë·ªãnh
                    self.auto_upload_with_default_config()

        except Exception as e:
            self.logger.error(f"L·ªói khi b·∫Øt ƒë·∫ßu upload: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu upload: {str(e)}")

    def refresh_upload_data(self):
        """L√†m m·ªõi d·ªØ li·ªáu upload"""
        try:
            self.logger.info("Refreshing upload data...")
            
            # Reload upload batch selector
            self.load_upload_batch_selector()
            
            # Refresh upload stats if batch is selected
            self.on_upload_batch_changed()
            
            # Refresh upload queue if there are folders loaded
            if hasattr(self, 'upload_folders') and self.upload_folders:
                self.refresh_upload_queue()
                
            # Update status
            self.upload_status_label.setText("üîÑ ƒê√£ l√†m m·ªõi d·ªØ li·ªáu upload")
            
            self.logger.info("Upload data refreshed successfully")
            
        except Exception as e:
            self.logger.error(f"Error refreshing upload data: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ l√†m m·ªõi d·ªØ li·ªáu upload: {str(e)}")

    def refresh_upload_queue(self):
        """L√†m m·ªõi h√†ng ƒë·ª£i upload"""
        try:
            if not hasattr(self, 'upload_folders') or not self.upload_folders:
                self.upload_status_label.setText("Kh√¥ng c√≥ d·ªØ li·ªáu trong h√†ng ƒë·ª£i ƒë·ªÉ l√†m m·ªõi")
                return
                
            # Clear current table
            self.upload_queue_table.setRowCount(0)
            
            # Re-add all folders to queue with updated status
            valid_folders = []
            for folder in self.upload_folders:
                # Re-validate folder
                if self.validate_folder_for_upload(folder):
                    # Check if folder is already processed
                    if not self.is_folder_already_processed(folder):
                        self.add_folder_to_upload_queue(folder)
                        valid_folders.append(folder)
                        
            # Update folders list with only valid ones
            self.upload_folders = valid_folders
            
            # Update button states
            has_folders = len(self.upload_folders) > 0
            self.clear_queue_btn.setEnabled(has_folders)
            self.start_upload_btn.setEnabled(has_folders)
            self.config_upload_btn.setEnabled(has_folders)
            
            # Update status
            removed_count = len([f for f in self.upload_folders]) - len(valid_folders)
            if removed_count > 0:
                self.upload_status_label.setText(f"üîÑ ƒê√£ l√†m m·ªõi h√†ng ƒë·ª£i - Lo·∫°i b·ªè {removed_count} s·∫£n ph·∫©m ƒë√£ x·ª≠ l√Ω")
            else:
                self.upload_status_label.setText(f"üîÑ ƒê√£ l√†m m·ªõi h√†ng ƒë·ª£i - {len(valid_folders)} s·∫£n ph·∫©m s·∫µn s√†ng")
                
        except Exception as e:
            self.logger.error(f"Error refreshing upload queue: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ l√†m m·ªõi h√†ng ƒë·ª£i: {str(e)}")

    def clear_upload_queue(self):
        """X√≥a h√†ng ƒë·ª£i upload"""
        try:
            reply = QMessageBox.question(
                self, "X√°c nh·∫≠n", 
                "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô h√†ng ƒë·ª£i upload?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )
            
            if reply == QMessageBox.StandardButton.Yes:
                self.upload_folders = []
                self.upload_queue_table.setRowCount(0)
                
                # Disable buttons
                self.clear_queue_btn.setEnabled(False)
                self.start_upload_btn.setEnabled(False)
                self.config_upload_btn.setEnabled(False)
                self.remove_selected_btn.setEnabled(False)
                
                # Update status
                self.upload_status_label.setText("ƒê√£ x√≥a h√†ng ƒë·ª£i upload")
                
        except Exception as e:
            self.logger.error(f"Error clearing upload queue: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ x√≥a h√†ng ƒë·ª£i: {str(e)}")

    def remove_selected_from_queue(self):
        """X√≥a c√°c items ƒë∆∞·ª£c ch·ªçn t·ª´ h√†ng ƒë·ª£i"""
        try:
            selected_rows = set()
            for item in self.upload_queue_table.selectedItems():
                selected_rows.add(item.row())
                
            if not selected_rows:
                QMessageBox.warning(self, "C·∫£nh b√°o", "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt s·∫£n ph·∫©m ƒë·ªÉ x√≥a!")
                return
                
            # Remove from upload_folders list
            rows_to_remove = sorted(selected_rows, reverse=True)
            for row in rows_to_remove:
                if row < len(self.upload_folders):
                    self.upload_folders.pop(row)
                    
            # Refresh the queue table
            self.refresh_upload_queue()
            
        except Exception as e:
            self.logger.error(f"Error removing selected from queue: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ x√≥a items ƒë√£ ch·ªçn: {str(e)}")

    def auto_upload_with_default_config(self):
        """T·ª± ƒë·ªông upload v·ªõi c·∫•u h√¨nh m·∫∑c ƒë·ªãnh"""
        try:
            # L·∫•y sites
            sites = self.db_manager.get_active_sites()
            if not sites:
                QMessageBox.warning(
                    self, "C·∫£nh b√°o", 
                    "Kh√¥ng c√≥ site WooCommerce n√†o ho·∫°t ƒë·ªông!\n"
                    "Vui l√≤ng th√™m v√† k√≠ch ho·∫°t site trong tab 'Qu·∫£n l√Ω Site'."
                )
                return

            # Import ProductUploadDialog
            from .product_upload_dialog import ProductUploadDialog

            # T·∫°o dialog v·ªõi auto_start=True
            dialog = ProductUploadDialog(
                parent=self, 
                sites=sites, 
                db_manager=self.db_manager, 
                selected_folders=self.upload_folders
            )

            # √Åp d·ª•ng c·∫•u h√¨nh hi·ªán t·∫°i n·∫øu c√≥
            if self.upload_config.get('configured', False):
                self.apply_config_to_dialog(dialog)

            # K·∫øt n·ªëi signal ƒë·ªÉ theo d√µi k·∫øt qu·∫£ upload
            dialog.product_uploaded.connect(self.on_product_uploaded_from_dialog)

            # T·ª± ƒë·ªông b·∫Øt ƒë·∫ßu upload lu√¥n
            QTimer.singleShot(500, lambda: self.auto_start_upload_in_dialog(dialog))

            # Hi·ªÉn th·ªã dialog
            result = dialog.exec()

            if result == QDialog.DialogCode.Accepted:
                # Upload th√†nh c√¥ng, clear queue v√† refresh data
                self.upload_folders = []
                self.upload_queue_table.setRowCount(0)
                self.config_upload_btn.setEnabled(False)
                self.start_upload_btn.setEnabled(False)
                self.upload_status_label.setText("Upload ho√†n th√†nh, ƒë√£ clear h√†ng ƒë·ª£i")

                # Refresh data trong b·∫£ng chi ti·∫øt
                self.load_detailed_data()
                self.load_summary()

                QMessageBox.information(
                    self, "Th√†nh c√¥ng", 
                    "ƒê√£ ho√†n th√†nh upload s·∫£n ph·∫©m!\n"
                    "D·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t trong database."
                )
            else:
                # User cancel ho·∫∑c c√≥ l·ªói
                self.upload_status_label.setText("ƒê√£ h·ªßy upload, d·ªØ li·ªáu v·∫´n trong h√†ng ƒë·ª£i")

        except Exception as e:
            self.logger.error(f"L·ªói auto upload: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ auto upload: {str(e)}")

    def apply_config_to_dialog(self, dialog):
        """√Åp d·ª•ng c·∫•u h√¨nh hi·ªán t·∫°i v√†o dialog"""
        try:
            config = self.upload_config

            # Thi·∫øt l·∫≠p site
            site_id = config.get('site_id')
            if site_id and hasattr(dialog, 'bulk_site_combo'):
                for i in range(dialog.bulk_site_combo.count()):
                    if dialog.bulk_site_combo.itemData(i) == site_id:
                        dialog.bulk_site_combo.setCurrentIndex(i)
                        break

            # Thi·∫øt l·∫≠p category
            category_id = config.get('category_id')
            if category_id and hasattr(dialog, 'bulk_category_combo'):
                # Update category combo theo site
                dialog.on_bulk_site_changed()
                for i in range(dialog.bulk_category_combo.count()):
                    if dialog.bulk_category_combo.itemData(i) == category_id:
                        dialog.bulk_category_combo.setCurrentIndex(i)
                        break

            #            # Thi·∫øt l·∫≠p c√°c th√¥ng s·ªë kh√°c
            if hasattr(dialog, 'bulk_status_combo'):
                status = config.get('status', 'draft')
                index = dialog.bulk_status_combo.findText(status)
                if index >= 0:
                    dialog.bulk_status_combo.setCurrentIndex(index)

            if hasattr(dialog, 'bulk_regular_price'):
                price = config.get('price', 25.0)
                dialog.bulk_regular_price.setValue(price)

            if hasattr(dialog, 'upload_delay'):
                delay = config.get('delay', 3)
                dialog.upload_delay.setValue(delay)

            self.logger.info("ƒê√£ √°p d·ª•ng c·∫•u h√¨nh upload v√†o dialog")

        except Exception as e:
            self.logger.error(f"L·ªói apply config to dialog: {str(e)}")

    def auto_start_upload_in_dialog(self, dialog):
        """T·ª± ƒë·ªông b·∫Øt ƒë·∫ßu upload trong dialog"""
        try:
            if hasattr(dialog, 'start_bulk_upload'):
                # T·ª± ƒë·ªông nh·∫•n n√∫t upload
                dialog.start_bulk_upload()
                self.logger.info("ƒê√£ t·ª± ƒë·ªông b·∫Øt ƒë·∫ßu bulk upload")
            else:
                self.logger.warning("Dialog kh√¥ng c√≥ method start_bulk_upload")

        except Exception as e:
            self.logger.error(f"L·ªói auto start upload in dialog: {str(e)}")
            QMessageBox.critical(
                self, "L·ªói", 
                f"Kh√¥ng th·ªÉ t·ª± ƒë·ªông b·∫Øt ƒë·∫ßu upload:\n{str(e)}\n"
                "Vui l√≤ng nh·∫•n n√∫t 'ƒêƒÉng h√†ng lo·∫°t' trong dialog."
            )

    def pause_upload(self):
        """T·∫°m d·ª´ng upload"""
        try:
            if hasattr(self, 'upload_worker') and self.upload_worker:
                self.upload_worker.pause()
                self.pause_upload_btn.setEnabled(False)
                self.resume_upload_btn.setEnabled(True)
                self.resume_upload_btn.setVisible(True)
                self.upload_status_label.setText("Upload ƒë√£ t·∫°m d·ª´ng")

        except Exception as e:
            self.logger.error(f"L·ªói khi t·∫°m d·ª´ng upload: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ t·∫°m d·ª´ng upload: {str(e)}")

    def resume_upload(self):
        """Ti·∫øp t·ª•c upload"""
        try:
            if hasattr(self, 'upload_worker') and self.upload_worker:
                self.upload_worker.resume()
                self.pause_upload_btn.setEnabled(True)
                self.resume_upload_btn.setEnabled(False)
                self.resume_upload_btn.setVisible(False)
                self.upload_status_label.setText("ƒêang ti·∫øp t·ª•c upload...")

        except Exception as e:
            self.logger.error(f"L·ªói khi ti·∫øp t·ª•c upload: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ ti·∫øp t·ª•c upload: {str(e)}")

    def stop_upload(self):
        """D·ª´ng upload ho√†n to√†n"""
        try:
            reply = QMessageBox.question(
                self, "X√°c nh·∫≠n", 
                "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën d·ª´ng upload?\nC√°c s·∫£n ph·∫©m ƒë√£ upload s·∫Ω kh√¥ng b·ªã ·∫£nh h∆∞·ªüng.",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                if hasattr(self, 'upload_worker') and self.upload_worker:
                    self.upload_worker.stop()
                    self.upload_worker.wait()  # Wait for thread to finish

                self.on_upload_finished()
                self.upload_status_label.setText("Upload ƒë√£ b·ªã d·ª´ng")

        except Exception as e:
            self.logger.error(f"L·ªói khi d·ª´ng upload: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ d·ª´ng upload: {str(e)}")

    def clear_upload_queue(self):
        """Clear h√†ng ƒë·ª£i upload"""
        try:
            reply = QMessageBox.question(
                self, "X√°c nh·∫≠n", 
                "B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô h√†ng ƒë·ª£i upload?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
                QMessageBox.StandardButton.No
            )

            if reply == QMessageBox.StandardButton.Yes:
                self.upload_folders = []
                self.upload_queue_table.setRowCount(0)
                self.config_upload_btn.setEnabled(False)
                self.start_upload_btn.setEnabled(False)
                self.upload_status_label.setText("ƒê√£ x√≥a h√†ng ƒë·ª£i upload")

                QMessageBox.information(self, "Th√†nh c√¥ng", "ƒê√£ x√≥a to√†n b·ªô h√†ng ƒë·ª£i upload")

        except Exception as e:
            self.logger.error(f"L·ªói khi clear upload queue: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ clear h√†ng ƒë·ª£i: {str(e)}")

    def remove_selected_from_queue(self):
        """X√≥a item ƒë∆∞·ª£c ch·ªçn kh·ªèi h√†ng ƒë·ª£i upload"""
        try:
            current_row = self.upload_queue_table.currentRow()
            if current_row < 0:
                QMessageBox.information(self, "Th√¥ng b√°o", "Vui l√≤ng ch·ªçn m·ªôt item ƒë·ªÉ x√≥a!")
                return

            # Remove from upload_folders list
            if current_row < len(self.upload_folders):
                removed_folder = self.upload_folders.pop(current_row)
                folder_name = removed_folder.get('data_name', 'Unknown')

                # Remove from table
                self.upload_queue_table.removeRow(current_row)

                # Update buttons
                if not self.upload_folders:
                    self.config_upload_btn.setEnabled(False)
                    self.start_upload_btn.setEnabled(False)
                    self.upload_status_label.setText("H√†ng ƒë·ª£i tr·ªëng")
                else:
                    self.upload_status_label.setText(f"C√≤n {len(self.upload_folders)} item trong h√†ng ƒë·ª£i")

                QMessageBox.information(self, "Th√†nh c√¥ng", f"ƒê√£ x√≥a '{folder_name}' kh·ªèi h√†ng ƒë·ª£i")

        except Exception as e:
            self.logger.error(f"L·ªói khi x√≥a item kh·ªèi queue: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ x√≥a item: {str(e)}")

    def update_upload_status(self, folder, status):
        """C·∫≠p nh·∫≠t tr·∫°ng th√°i upload trong queue table"""
        try:
            # Find the row in the table for the given folder
            row = -1
            for i in range(self.upload_queue_table.rowCount()):
                item = self.upload_queue_table.item(i, 1)  # Path is in column 1
                if item and item.text() == folder.get('path'):
                    row = i
                    break

            if row >= 0:
                self.upload_queue_table.setItem(row, 6, QTableWidgetItem(status))  # Update status in column 6

        except Exception as e:
            self.logger.error(f"L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i upload: {str(e)}")

    def update_upload_progress(self, completed, total):
        """C·∫≠p nh·∫≠t ti·∫øn ƒë·ªô upload"""
        try:
            percent = int((completed / total) * 100) if total > 0 else 0
            self.upload_progress_bar.setValue(percent)
            self.upload_progress_label.setText(f"{completed}/{total}")

        except Exception as e:
            self.logger.error(f"L·ªói khi c·∫≠p nh·∫≠t ti·∫øn ƒë·ªô upload: {str(e)}")

    def update_upload_log(self, folder, log):
        """C·∫≠p nh·∫≠t log upload trong queue table"""
        try:
            # Find the row in the table for the given folder
            row = -1
            for i in range(self.upload_queue_table.rowCount()):
                item = self.upload_queue_table.item(i, 1)  # Path is in column 1
                if item and item.text() == folder.get('path'):
                    row = i
                    break

            if row >= 0:
                self.upload_queue_table.setItem(row, 7, QTableWidgetItem(log))  # Update log in column 7

        except Exception as e:
            self.logger.error(f"L·ªói khi c·∫≠p nh·∫≠t log upload: {str(e)}")

    def on_upload_finished(self):
        """X·ª≠ l√Ω khi upload ho√†n th√†nh (ho·∫∑c d·ª´ng)"""
        try:
            # Re-enable controls
            self.load_selected_btn.setEnabled(True)
            self.config_upload_btn.setEnabled(True)
            self.start_upload_btn.setEnabled(True)

            # Reset control buttons
            if hasattr(self, 'pause_upload_btn'):
                self.pause_upload_btn.setEnabled(False)
            if hasattr(self, 'resume_upload_btn'):
                self.resume_upload_btn.setEnabled(False)
                self.resume_upload_btn.setVisible(False)
            if hasattr(self, 'stop_upload_btn'):
                self.stop_upload_btn.setEnabled(False)

            # Reset UI
            self.upload_status_label.setText("Upload ho√†n th√†nh")
            self.upload_progress_bar.setVisible(False)
            self.upload_progress_bar.setValue(0)

            if hasattr(self, 'upload_worker') and self.upload_worker:
                completed = getattr(self.upload_worker, 'completed_count', 0)
                total = len(self.upload_folders) if self.upload_folders else 0
                if total > 0:
                    QMessageBox.information(self, "Th√¥ng b√°o", f"ƒê√£ upload {completed}/{total} m·ª•c.")

            self.upload_worker = None  # Clear worker

        except Exception as e:
            self.logger.error(f"L·ªói khi upload ho√†n th√†nh: {str(e)}")
            QMessageBox.critical(self, "L·ªói", f"L·ªói trong qu√° tr√¨nh upload: {str(e)}")

    def on_search_changed(self):
        """X·ª≠ l√Ω khi thay ƒë·ªïi t·ª´ kh√≥a t√¨m ki·∫øm"""
        search_text = self.search_input.text().lower().strip()

        for row in range(self.data_table.rowCount()):
            show_row = True

            if search_text:
                # T√¨m ki·∫øm trong t·∫•t c·∫£ c√°c c·ªôt
                row_text = ""
                for col in range(self.data_table.columnCount()):
                    item = self.data_table.item(row, col)
                    if item:
                        row_text += item.text().lower() + " "

                show_row = search_text in row_text

            self.data_table.setRowHidden(row, not show_row)

    def on_bulk_edit_selected(self):
        """S·ª≠a h√†ng lo·∫°t d·ªØ li·ªáu ƒë∆∞·ª£c ch·ªçn"""
        selected_items = self.data_table.selectedItems()
        if not selected_items:
            QMessageBox.warning(self, "C·∫£nh b√°o", "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt d√≤ng!")
            return

        # Import dialog s·ª≠a h√†ng lo·∫°t
        from .bulk_folder_edit_dialog import BulkFolderEditDialog

        dialog = BulkFolderEditDialog(self)
        if dialog.exec() == QDialog.DialogCode.Accepted:
            update_data = dialog.get_update_data()

            # C·∫≠p nh·∫≠t cho t·∫•t c·∫£ folder ƒë∆∞·ª£c ch·ªçn
            updated_count = 0
            for row in range(self.data_table.rowCount()):
                if self.data_table.item(row, 0).isSelected():
                    item_data = self.data_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
                    if item_data and item_data['type'] == 'folder_scan':
                        folder_id = item_data['id']
                        if self.db_manager.update_folder_scan(folder_id, update_data):
                            updated_count += 1

            QMessageBox.information(
                self, "Th√†nh c√¥ng", 
                f"ƒê√£ c·∫≠p nh·∫≠t {updated_count} folder th√†nh c√¥ng!"
            )
            self.load_detailed_data()

    def on_export_selected_data(self):
        """Xu·∫•t d·ªØ li·ªáu ƒë∆∞·ª£c ch·ªçn"""
        selected_rows = set()
        for item in self.data_table.selectedItems():
            selected_rows.add(item.row())

        if not selected_rows:
            QMessageBox.warning(self, "C·∫£nh b√°o", "Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt d√≤ng!")
            return

        # Ch·ªçn file ƒë·ªÉ l∆∞u
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Xu·∫•t d·ªØ li·ªáu", "", 
            "JSON files (*.json);;CSV files (*.csv)"
        )

        if file_path:
            try:
                export_data = []
                for row in selected_rows:
                    item_data = self.data_table.item(row, 0).data(Qt.ItemDataRole.UserRole)
                    if item_data:
                        export_data.append(item_data['data'])

                if file_path.endswith('.json'):
                    import json
                    with open(file_path, 'w', encoding='utf-8') as f:
                        json.dump(export_data, f, ensure_ascii=False, indent=2)
                elif file_path.endswith('.csv'):
                    import csv
                    if export_data:
                        with open(file_path, 'w', newline='', encoding='utf-8') as f:
                            writer = csv.DictWriter(f, fieldnames=export_data[0].keys())
                            writer.writeheader()
                            writer.writerows(export_data)

                QMessageBox.information(
                    self, "Th√†nh c√¥ng", 
                    f"ƒê√£ xu·∫•t {len(export_data)} b·∫£n ghi ra {file_path}"
                )

            except Exception as e:
                QMessageBox.critical(self, "L·ªói", f"L·ªói xu·∫•t d·ªØ li·ªáu: {str(e)}")


class DataEditDialog(QDialog):
    """Dialog ch·ªânh s·ª≠a folder scan data"""

    def __init__(self, parent=None, folder_data=None):
        super().__init__(parent)
        self.folder_data = folder_data or {}
        self.init_ui()
        self.load_data()

    def init_ui(self):
        """Kh·ªüi t·∫°o giao di·ªán"""
        self.setWindowTitle("‚úèÔ∏è Ch·ªânh s·ª≠a Folder Scan Data")
        self.setModal(True)
        self.resize(500, 400)

        layout = QVBoxLayout(self)

        # Form fields
        form_group = QGroupBox("üìù Th√¥ng tin c·∫ßn ch·ªânh s·ª≠a")
        form_layout = QFormLayout(form_group)

        self.data_name_edit = QLineEdit()
        form_layout.addRow("T√™n data:", self.data_name_edit)

        self.original_title_edit = QLineEdit()
        form_layout.addRow("Ti√™u ƒë·ªÅ g·ªëc:", self.original_title_edit)

        self.path_edit = QLineEdit()
        form_layout.addRow("ƒê∆∞·ªùng d·∫´n:", self.path_edit)

        self.status_combo = QComboBox()
        self.status_combo.addItems(["pending", "completed", "uploaded", "error"])
        form_layout.addRow("Tr·∫°ng th√°i:", self.status_combo)

        self.image_count_spin = QSpinBox()
        self.image_count_spin.setRange(0, 999999)
        form_layout.addRow("S·ªë th∆∞ m·ª•c:", self.image_count_spin)

        self.notes_edit = QTextEdit()
        self.notes_edit.setMaximumHeight(100)
        form_layout.addRow("Ghi ch√∫:", self.notes_edit)

        layout.addWidget(form_group)

        # Buttons
        buttons_layout = QHBoxLayout()

        self.save_btn = QPushButton("üíæ L∆∞u")
        self.save_btn.clicked.connect(self.accept)
        buttons_layout.addWidget(self.save_btn)

        self.cancel_btn = QPushButton("‚ùå H·ªßy")
        self.cancel_btn.clicked.connect(self.reject)
        buttons_layout.addWidget(self.cancel_btn)

        layout.addLayout(buttons_layout)

    def load_data(self):
        """Load d·ªØ li·ªáu hi·ªán t·∫°i v√†o form"""
        try:
            self.data_name_edit.setText(self.folder_data.get('data_name', ''))
            self.original_title_edit.setText(self.folder_data.get('original_title', ''))
            self.path_edit.setText(self.folder_data.get('path', ''))

            status = self.folder_data.get('status', 'pending')
            index = self.status_combo.findText(status)
            if index >= 0:
                self.status_combo.setCurrentIndex(index)

            self.image_count_spin.setValue(self.folder_data.get('image_count', 0))
            self.notes_edit.setPlainText(self.folder_data.get('notes', ''))

        except Exception as e:
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ load d·ªØ li·ªáu: {str(e)}")

    def get_updated_data(self):
        """L·∫•y d·ªØ li·ªáu ƒë√£ ch·ªânh s·ª≠a"""
        return {
            'data_name': self.data_name_edit.text().strip(),
            'original_title': self.original_title_edit.text().strip(),
            'path': self.path_edit.text().strip(),
            'status': self.status_combo.currentText(),
            'image_count': self.image_count_spin.value(),
            'notes': self.notes_edit.toPlainText().strip()
        }


class DataDetailsDialog(QDialog):
    """Dialog xem chi ti·∫øt data (saved scan ho·∫∑c folder scan)"""

    def __init__(self, parent=None, data=None, data_type="unknown"):
        super().__init__(parent)
        self.data = data or {}
        self.data_type = data_type
        self.init_ui()
        self.load_data()

    def init_ui(self):
        """Kh·ªüi t·∫°o giao di·ªán"""
        title = "üëÅÔ∏è Chi ti·∫øt Saved Scan" if self.data_type == 'saved_scan' else "üëÅÔ∏è Chi ti·∫øt Folder Scan"
        self.setWindowTitle(title)
        self.setModal(True)
        self.resize(700, 600)

        layout = QVBoxLayout(self)

        # Details display
        details_group = QGroupBox("üìã Th√¥ng tin chi ti·∫øt")
        details_layout = QVBoxLayout(details_group)

        self.details_text = QTextEdit()
        self.details_text.setReadOnly(True)
        details_layout.addWidget(self.details_text)

        layout.addWidget(details_group)

        # Buttons
        buttons_layout = QHBoxLayout()

        # Load button ch·ªâ hi·ªÉn th·ªã cho saved scans
        if self.data_type == 'saved_scan':
            self.load_btn = QPushButton("üìã Load v√†o qu·∫£n l√Ω")
            self.load_btn.clicked.connect(self.load_saved_scan_data)
            buttons_layout.addWidget(self.load_btn)

        buttons_layout.addStretch()

        close_btn = QPushButton("‚ùå ƒê√≥ng")
        close_btn.clicked.connect(self.accept)
        buttons_layout.addWidget(close_btn)

        layout.addLayout(buttons_layout)

    def load_data(self):
        """Load v√† hi·ªÉn th·ªã d·ªØ li·ªáu chi ti·∫øt"""
        try:
            if self.data_type == 'saved_scan':
                self.load_saved_scan_details()
            else:
                self.load_folder_scan_details()

        except Exception as e:
            self.details_text.setPlainText(f"L·ªói hi·ªÉn th·ªã chi ti·∫øt: {str(e)}")

    def load_saved_scan_details(self):
        """Hi·ªÉn th·ªã chi ti·∫øt saved scan"""
        try:
            import json

            details_html = "<h3>üì¶ Th√¥ng tin Saved Scan</h3>"
            details_html += "<table border='1' cellpadding='5' cellspacing='0' style='border-collapse: collapse; width: 100%;'>"

            # Basic info
            details_html += f"<tr><td style='font-weight: bold; background-color: #e3f2fd;'>T√™n</td><td>{self.data.get('name', 'N/A')}</td></tr>"
            details_html += f"<tr><td style='font-weight: bold; background-color: #e3f2fd;'>M√¥ t·∫£</td><td>{self.data.get('description', 'N/A')}</td></tr>"
            details_html += f"<tr><td style='font-weight: bold; background-color: #e3f2fd;'>S·ªë l∆∞·ª£ng folder</td><td>{self.data.get('folder_count', 0)}</td></tr>"
            details_html += f"<tr><td style='font-weight: bold; background-color: #e3f2fd;'>Ng√†y t·∫°o</td><td>{self.data.get('created_at', 'N/A')}</td></tr>"

            details_html += "</table>"

            # Folders data preview
            data_json = self.data.get('data', '[]')
            try:
                if isinstance(data_json, str):
                    folders_data = json.loads(data_json)
                else:
                    folders_data = data_json

                details_html += f"<h4>üìÅ Danh s√°ch Folders ({len(folders_data)} items)</h4>"
                details_html += "<table border='1' cellpadding='3' cellspacing='0' style='border-collapse: collapse; width: 100%; font-size: 12px;'>"
                details_html += "<tr style='background-color: #f5f5f5;'><th>T√™n</th><th>ƒê∆∞·ªùng d·∫´n</th><th>S·ªë ·∫£nh</th><th>Tr·∫°ng th√°i</th></tr>"

                for i, folder in enumerate(folders_data[:10]):  # Hi·ªÉn th·ªã t·ªëi ƒëa 10 folders
                    name = folder.get('data_name') or folder.get('original_title', 'N/A')
                    path = folder.get('path', 'N/A')
                    if len(path) > 50:
                        path = path[:50] + "..."
                    image_count = folder.get('image_count', 0)
                    status = folder.get('status', 'N/A')

                    details_html += f"<tr><td>{name}</td><td>{path}</td><td>{image_count}</td><td>{status}</td></tr>"

                if len(folders_data) > 10:
                    details_html += f"<tr><td colspan='4' style='text-align: center; font-style: italic;'>... v√† {len(folders_data) - 10} folders kh√°c</td></tr>"

                details_html += "</table>"

            except Exception as e:
                details_html += f"<p style='color: red;'>L·ªói hi·ªÉn th·ªã folders data: {str(e)}</p>"

            self.details_text.setHtml(details_html)

        except Exception as e:
            self.details_text.setPlainText(f"L·ªói hi·ªÉn th·ªã saved scan: {str(e)}")

    def load_folder_scan_details(self):
        """Hi·ªÉn th·ªã chi ti·∫øt folder scan"""
        try:
            details_html = "<h3>üìÅ Th√¥ng tin Folder Scan</h3>"
            details_html += "<table border='1' cellpadding='5' cellspacing='0' style='border-collapse: collapse; width: 100%;'>"

            for key, value in self.data.items():
                if key in ['data', 'scan_results', 'metadata']:
                    # Format JSON data
                    if isinstance(value, (dict, list)):
                        import json
                        value = json.dumps(value, indent=2, ensure_ascii=False)

                details_html += f"<tr><td style='font-weight: bold; background-color: #f0f0f0;'>{key}</td><td>{value}</td></tr>"

            details_html += "</table>"
            self.details_text.setHtml(details_html)

        except Exception as e:
            self.details_text.setPlainText(f"L·ªói hi·ªÉn th·ªã folder scan: {str(e)}")

    def load_saved_scan_data(self):
        """Load saved scan data v√†o database"""
        try:
            # Implement logic ƒë·ªÉ load saved scan data v√†o current folder scans
            QMessageBox.information(self, "Th√¥ng b√°o", "Ch·ª©c nƒÉng load saved scan data s·∫Ω ƒë∆∞·ª£c tri·ªÉn khai sau!")

        except Exception as e:
            QMessageBox.critical(self, "L·ªói", f"Kh√¥ng th·ªÉ load saved scan data: {str(e)}")